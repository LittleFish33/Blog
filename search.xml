<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SYSU计算机组成原理与接口实验————单周期CPU设计]]></title>
    <url>%2F%2FCOD%2FSingleCycleCPU%2F</url>
    <content type="text"><![CDATA[一、 提供的资料老师提供的文件，包括实验要求，实验原理，实验说明，和测试要求和方法 实验说明 关于测试单周期CPU的简单方法 单周期CPU设计实验基本要求 Basys3板上数码管的使用 ==&gt; 传送门 二、实现过程（一）CPU设计思想首先，根据要求，该CPU实现主要包括以下模块： 文件名 功能 top.v 顶层文件 （Basys3板子使用） CPU.v 整个CPU的框架文件 ControlUnit.v 控制单元 ALU.v 算术逻辑单元 decoder.v 译码器 Extend.v 符号位扩展 PC.v 程序计数器 RAM.v 存储器 ROM.v 存放指令的存储器 RegFile.v 寄存器组 Head.v 一些通用信息 ButtonClick.v 按钮防抖 （Basys3板子使用） CLOCK_DIV.v 分频 （Basys3板子使用） Switch.v 根据对应开关控制Led灯显示对应数据 （Basys3板子使用） Display.v 控制Led灯显示 （Basys3板子使用） top_tb.v 测试文件 （二）整个CPU工作的实现过程0. head.v首先，我们需要将一些常用的信息放在一个单独的文件head.v中，关于这个文件里的一些变量的作用你可能暂时不是很了解，但是可以先不要在意，下面使用到这些信息的时候会再次介绍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//head.v/* * ALU的输入来源：ALUSrcA, ALUSrcB * ---------------------------------------------------------------------------------------------------------------------------------------- * 控制信号名 | 状态 '0' | 状态 '1' * ---------------------------------------------------------------------------------------------------------------------------------------- * ALUSrcA | 来自寄存器堆data1输出，相关指令： | 来自sign或zero扩展的立即数，即 &#123;&#123;27&#123;0&#125;&#125;,sa&#125;，相关指令：sll * | add、sub、addi、or、and、ori、beq、bne、slti、sw、lw | * ---------------------------------------------------------------------------------------------------------------------------------------- * ALUSrcB | 来自寄存器堆data2输出，相关指令： | 来自sign或zero扩展的立即数，相关指令：addi、ori、slti、sw、lw * | add、sub、or、and、sll、beq、bne | * ---------------------------------------------------------------------------------------------------------------------------------------- */`define FromData 1'b0`define FromSA 1'b1`define FromImmd 1'b1/* * DBDataSrc，选择目前指令的输出来自ALU运算输出结果还是来自数据存储器 * ---------------------------------------------------------------------------------------------------------------------------------------- * 控制信号名 | 状态 '0' | 状态 '1' * ---------------------------------------------------------------------------------------------------------------------------------------- * DBDataSrc | 来自ALU运算结果的输出，相关指令：add、addi、sub、ori、 | 来自数据存储器（Data MEM）的输出，相关指令：lw * | or、and、slti、sll | * ---------------------------------------------------------------------------------------------------------------------------------------- */`define FromALU 1'b0`define FromDataMEM 1'b1/* * RegDst，写寄存器组寄存器的地址 * ---------------------------------------------------------------------------------------------------------------------------------------- * 控制信号名 | 状态 '0' | 状态 '1' * ---------------------------------------------------------------------------------------------------------------------------------------- * RegDst | 来自rt字段，相关指令：addi、ori、lw、slti | 来自rd字段，相关指令：add、sub、and、or、sll * ---------------------------------------------------------------------------------------------------------------------------------------- */`define FromRt 1'b0`define FromRd 1'b1/* * ExtSel，扩展相关操作，判断是0扩展 还是符号扩展 * ---------------------------------------------------------------------------------------------------------------------------------------- * 控制信号名 | 状态 '0' | 状态 '1' * ---------------------------------------------------------------------------------------------------------------------------------------- * ExtSel | 0扩展，相关指令：ori | 符号扩展，相关指令：addi、slti、sw、lw、beq、bne * ---------------------------------------------------------------------------------------------------------------------------------------- */`define ZeroExtend 1'b0`define SignExtend 1'b1/* * PCSrc，指示下一步指令的来源 * ---------------------------------------------------------------------------------------------------------------------------------------- * 控制信号名状态 | 操作 * ---------------------------------------------------------------------------------------------------------------------------------------- * 00 | pc&lt;－pc+4，相关指令：add、addi、sub、or、ori、and、slti、sll、sw、lw、beq(zero=0)、bne(zero=1)；指向下一条指令 * ---------------------------------------------------------------------------------------------------------------------------------------- * 01 | pc&lt;－pc+4+(sign-extend)immediate，相关指令：beq(zero=1)、bne(zero=0)；跳转到相对与当前指令地址 xx 的位置 * ---------------------------------------------------------------------------------------------------------------------------------------- * 10 | pc&lt;－&#123;(pc+4)[31:28],addr[27:2],2&#123;0&#125;&#125;，相关指令：j； 直接跳转到某个位置 * ---------------------------------------------------------------------------------------------------------------------------------------- * 11 | 未用 * ---------------------------------------------------------------------------------------------------------------------------------------- */`define NextIns 2'b00`define RelJump 2'b01`define AbsJump 2'b10`define HALT 2'b11/* * 指令的前六位操作码 */`define opADD 6'b000000`define opADDI 6'b000001`define opSUB 6'b000010`define opORI 6'b010000`define opAND 6'b010001`define opOR 6'b010010 `define opSLL 6'b011000 // 左移指令`define opSLTI 6'b011011 // 与立即数进行比较指令，less than`define opSW 6'b100110`define opLW 6'b100111`define opBEQ 6'b110000`define opBNE 6'b110001`define opJ 6'b111000`define opHALT 6'b111111/* * ALU 运算功能表 */`define ALUAdd 3'b000`define ALUSub 3'b001`define ALUSll 3'b010`define ALUOr 3'b011`define ALUAnd 3'b100`define ALUCompareUnsign 3'b101`define ALUCompareSign 3'b110`define ALUXor 3'b111 下面，我们将整个CPU的实现拆分成多步，一个模块一个模块的组合起我们的单周期CPU 1. 程序计数器 PC首先是程序计数器，这里使用两个部件，PC和GetNextPC，GetNextPC将根据指令的类型【跳转指令（使用到26位立即数），分支指令（使用到16位立即数），下一条指令（PC + 4）】计算下一条指令的地址，而PC的将从GetNextPC中得到的下一条指令的地址赋给address；address即表示指令的地址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//PC.v`timescale 1ns / 1ps`include "head.v"/* * PC 程序计数器 * @input clk 时钟信号 * @input RST reset信号，当reset信号为0时，不工作 * @input next 下一条指令的地址，用于将下一条指令的地址赋给取出的指令 * @output addr 要取出的指令的地址 */module PC( input clk, input RST, input [31:0]next, output reg [31:0]addr ); // 在 下一个时钟的上升沿或者reset按下 always@(posedge clk or negedge RST) begin addr &lt;= RST == 0 ? 0 : next; endendmodule/* * GetNextPC, 用于计算下一条指令的地址 * @input addr 当前指令的地址 * @input immd16 16位立即数，用于分支指令的跳转，beq，bneq * @input immd26 26为立即数，用于跳转指令的跳转，jump * @input PCSrc 下一条指令的得到依据，判断是pc+4，还是分支指令还是跳转指令 * @output next 计算得到的下一条指令的地址 */module GetNextPC( input [31:0] addr, input [15:0] immd16, input [25:0] immd26, input [1:0] PCSrc, output reg [31:0] next ); initial begin next = 0; end // 16立即数扩展到32位 wire [31:0]exd_immd16 = &#123; &#123;16&#123;immd16[15]&#125;&#125;, immd16&#125;; always@(*) begin case (PCSrc) `NextIns : next &lt;= addr + 4; `RelJump : next &lt;= (addr + 4 + (exd_immd16 &lt;&lt; 2)); `AbsJump : next &lt;= &#123;addr[31:28], immd26, 2'b00&#125;; `HALT : next &lt;= addr; endcase endendmodule 2. ROM得到了指令的地址，那么下一步就是获得从指令集中获取指令，我们将指令集存放ROM中，ROM接收一个输入：指令的地址；一个输出：32位的指令码； 123456789101112131415161718192021222324252627282930//ROM.v`timescale 1ns/1ps/* * ROM 存储器，从文件中取出指令 * @input mRD，由控制单元输入的信号，当mRD = 1 时，取指，反之，输出高阻态 * @input addr 要取出的指令的地址 * @output instruction 要取出的指令 */module ROM ( input mRD, input [31:0] addr, output reg [31:0] instruction ); reg [7:0] rom [0:71]; // 存储器定义必须用reg类型，存储器存储单元8位长度 initial begin // 加载数据到存储器rom。注意：必须使用绝对路径 $readmemb ("C:/Users/HP/Desktop/my/SingleCycleCPU/ROMdata/data.txt", rom); end // 存储器存储单元8位长度，指令32位长度 always @(*) begin if (mRD == 1) begin instruction[31:24] = rom[addr]; instruction[23:16] = rom[addr+1]; instruction[15:8] = rom[addr+2]; instruction[7:0] = rom[addr+3]; end else begin instruction[31:0] = &#123;32&#123;1'bz&#125;&#125;; end endendmodule data.txt 的内容即为你要测试的指令，这里使用的上面的文件关于测试单周期CPU的简单方法.pdf中提供的测试样例；下载链接： data.txt 3. Decoder 译码器获取32位指令码之后，下一步就是对指令进行解码，我们使用Decoder进行解码，为了适用于所有的指令，解码器将解码出所有的结果，有：op（操作码），rs（第一源操作数寄存器），rt（第二源操作数寄存器），rd（存放操作结果的目的寄存器），shamt（位移量），funct（功能码），immd16（16位立即数，适用于分支指令），immd26（26位立即数，适用于跳转指令），针对不同的指令，所有的指令字段不一定都会使用到，但我们需要解码所有的指令以适用所有的指令。需要注意到，这里的16位立即数和26位立即数就是（1）中提到的GetNextAddress的输入之一。 123456789101112131415161718192021222324252627282930313233343536373839//Decoder.v`include "head.v"`timescale 1ns / 1ps/* * Decoder, 译码器 * @input instruction 需要译码的指令 * @output op:指令的基本操作，成为操作码 * @output rs:第一源操作数寄存器 * @output rt:第二源操作数寄存器 * @output rd:存放操作结果的目的寄存器 * @output shamt:位移量 * @output funct:功能码，本次实验不需要使用到功能码 * @output immd16:16位立即数，用于分支指令，bneq和beq * @output immd26:26位立即数，用于跳转指令jump */module Decoder( input [31:0] instruction, output [5:0] op, output [4:0] rs, output [4:0] rt, output [4:0] rd, output [4:0] shamt, output [5:0] funct, output [15:0] immd16, output [25:0] immd26 ); /* * 针对不同的指令，该译码器不一定会使用所有取出的指令字段，如跳转指令的格式为op immd26， * 因此跳转指令将只使用取出的op 和 immd26 */ assign op = instruction[31:26]; assign rs = instruction[25:21]; assign rt = instruction[20:16]; assign rd = instruction[15:11]; assign shamt = instruction[10:6]; assign funct = instruction[5:0]; assign immd16 = instruction[15:0]; assign immd26 = instruction[25:0];endmodule 4. 控制单元 Control Unit使用解码器解码成功之后，我们就可以解码后的信号发送到控制单元，控制单元将根据相应的指令生成相应的控制信号，关于控制信号的作用可以参考上面的实验原理中关于控制信号的内容。控制单元Control Unit接收四个输入：解码器得到的操作码和函数功能码，ZERO和SIGN信号，输出包括：ALUSrcA，ALUSrcB,DBDataSrc，RegWr，mRD，mWR，RegDst，ExtSel，ALUop，具体功能为： 控制信号输出 功能 ALUSrcA 判断算术逻辑单元第一源操作数的来源是来自寄存器堆Data1还是移位 ALUSrcB 判断算术逻辑单元第二源操作数是来自寄存器堆Data2还是扩展后的立即数 DBDataSrc 判断写入存储器的数据是来自ALU的输出还是数据存储器 RegWr 判断是否执行写入寄存器 mRD 判断是否读存储器 mWR 判断是否写存储器 RegDst 如果要写寄存器的话，指明要写的寄存器地址时来自rt字段还是rd字段 ExtSel 判断是符号位扩展还是零扩展 ALUop 用于ALU的八种功能选择 （对应功能请查看上面提供的文件） 5. 寄存器组 RegFile下一步我们为我们的CPU添加寄存器组，寄存器组接收七个输入：时钟信号（寄存器组的读写发生在时钟脉冲上升沿），RST（RST=0时，停止寄存器的读写），RegWre （判断是否需要写寄存器），ReadReg1（指令中的rs字段需要读寄存器时，将通过这个端口），ReadReg2 （指令中的rt字段需要读寄存器时，将通过这个端口），WriteReg （指令需要写寄存器的时候，这将是数据写入的寄存器端口，其地址来源rt或rd字段）；对应的输出：WriteData（要写入的数据），ReadData1、ReadData2（要读入的寄存器）。 123456789101112131415161718192021222324252627282930313233343536373839//RegFile.v`timescale 1ns / 1ps/* * Register File：寄存器组 * @input CLK 时钟信号 * @input RST reset信号 * @input RegWre 判断是否需要写寄存器 * @input ReadReg1 rs寄存器地址输入端口 * @input ReadReg2 rt寄存器地址输入端口 * @input WriteReg 将数据写入的寄存器端口，其地址来源rt或rd字段 * @input WriteData 写入寄存器的数据输入端口 * @output ReadData1，rs寄存器数据输出端口 * @output ReadData2，rt寄存器数据输出端口 */module RegFile( input CLK, input RST, input RegWre, input [4:0] ReadReg1, input [4:0] ReadReg2, input [4:0] WriteReg, input [31:0] WriteData, output [31:0] ReadData1, output [31:0] ReadData2 ); reg [31:0] regFile[1:31]; // 寄存器定义必须用reg 类型 integer i; assign ReadData1 = (ReadReg1 == 0) ? 0 : regFile[ReadReg1]; // 读寄存器数据 assign ReadData2 = (ReadReg2 == 0) ? 0 : regFile[ReadReg2]; always @ (negedge CLK or negedge RST) begin // 必须用时钟边沿触发 if (RST==0) begin for(i=1;i&lt;32;i=i+1) regFile[i] &lt;= 0; end else if(RegWre == 1 &amp;&amp; WriteReg != 0) // WriteReg != 0，$0 寄存器不能修改 regFile[WriteReg] &lt;= WriteData; // 写寄存器 endendmodule 6. 立即数扩展在进入算数逻辑单元之前，我们需要先对立即数进行扩展才能进行相应的操作，所以我们先进入立即数扩展部件，其接收两个参数：16位立即数和extSel（用于判断是进行零扩展还是符号位扩展），产生一个32位的输出，作为扩展后的结果； 123456789101112131415161718//Extend.v`include "head.v"`timescale 1ns/ 1ps/* * Extend 用于进行符号位扩展 * @input immd16 16位立即数 * @input extSel 如果extSel=0，则进行零扩展，反之，进行符号位扩展 * @output exd_immd 符号位扩展后的结果 */module Extend( input [15:0] immd16, input extSel, output [31:0] exd_immd ); wire e; assign e = extSel &amp; immd16[15]; assign exd_immd = &#123;&#123;16&#123;e&#125;&#125;, immd16&#125;;endmodule 7. 算术逻辑单元 ALU终于到了我们的算数逻辑单元了，ALU接收三个输入：operation（操作码，对应上面实验原理的内容），regA（第一位操作数），regB（第二位操作数）；三个输出：result（ALU计算结果），zero（结果是否为0，用于分支指令beq，bneq），sign（结果的符号位，如果要进行符号位扩展）； 123456789101112131415161718192021222324252627282930313233343536373839404142//ALU.v`timescale 1ns / 1ps`include "head.v"/* * ALU 算术逻辑单元 * @input operation 要进行的操作 * @input regA 运算数 * @input regB 运算数 * @output result 结果输出 * @output zero 结果是不是为0 * @output sign 得到结果的符号位 */module ALU( input [2:0] operation, input [31:0] regA, input [31:0] regB, output reg [31:0] result, output zero, output sign ); assign zero = (result == 0) ?1:0; assign sign = result[31]; always @(*) begin case (operation) `ALUAdd : result = regA + regB; `ALUSub : result = regA - regB; `ALUAnd : result = regA &amp; regB; `ALUOr : result = regA | regB; `ALUCompareUnsign : result = (regA &lt; regB) ?1:0; // 不带符号比较 `ALUCompareSign : begin // 带符号比较 if (regA &lt; regB &amp;&amp;(( regA[31] == 0 &amp;&amp; regB[31]==0) || (regA[31] == 1 &amp;&amp; regB[31] == 1))) result = 1; else if (regA[31] == 0 &amp;&amp; regB[31]==1) result = 0; else if ( regA[31] == 1 &amp;&amp; regB[31]==0) result = 1; else result = 0; end `ALUSll : result = regB &lt;&lt; regA; default : result = 8'h00000000; endcase endendmodule 8. 存储器最后的最后，我们只差一个存储器了，存储器的内部是一个二维数组（要求数据存储器存储单元宽度一律使用8位，所以），数据将存放在数组中，接收输入：时钟信号（仅在时钟上升沿才能读写存储器），address（要读的数据的地址），writeData（如果执行的是sw操作，那么这就是我们要写的内容），mRD（当mRD = 1，执行lw指令），mWR（当mWR = 1，执行sw指令）；一个输出：Dataout（如果执行的是lw操作，这将是取出的内容）； 123456789101112131415161718192021222324252627282930313233343536//RAM.v`timescale 1ns / 1ps/* * Data Memory：数据存储器 * @input clk 时钟信号 * @input address 要读出/写入的地址 * @input writeData 要写入的数据 * @input mRD 为1，正常读；为0,输出高组态 * @input mWR 为1，写；为0，无操作 * @output Dataout 保存读出的数据 */module RAM( input clk, input [31:0] address, input [31:0] writeData, input mRD, input mWR, output [31:0] Dataout ); //一个二维数组作为存储器 reg [7:0] memory [0:63]; // 最多16个数据，因为好像模拟器上限好像是64个寄存器 // 读，lw指令 assign Dataout[31:24] = (mRD == 1)? memory[address + 3]:8'bz; assign Dataout[23:16] = (mRD == 1)? memory[address + 2]:8'bz; assign Dataout[15:8] = (mRD == 1)? memory[address + 1]:8'bz; assign Dataout[7:0] = (mRD == 1)? memory[address ]:8'bz; // 写，sw指令 always@( negedge clk ) begin if( mWR == 1) begin memory[address + 3] &lt;= writeData[31:24]; memory[address + 2] &lt;= writeData[23:16]; memory[address + 1] &lt;= writeData[15:8]; memory[address + 0] &lt;= writeData[7:0]; end endendmodule 9. 顶层模块所有模块编写好之后，我们就需要一个顶层模块将各模块组合在一起，这个模块就是CPU.v 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195//CPU.v`include "head.v"`timescale 1ns / 1psmodule CPU ( input clk, input RST // RST 为reset信号 ); wire [3:0] pos_ctrl; wire [7:0] num_ctrl; wire [31:0] address; wire [31:0] nextAddress; // 指令中的立即数部分 wire [15:0] immd16; wire [25:0] immd26; // PCSrc 用于指明下一条指令的来源，如pc + 4，,jump，bneq，beq wire [1:0] PCSrc; /* * 程序计数器，将下一条指令赋给当前的指令，相当于取指令 */ PC myPC( .clk(clk), .RST(RST), .next(nextAddress), .addr(address) ); /* * 针对不同的情况计算下一条指令的地址，如pc + 4， jump，bneq，beq */ GetNextPC myGetNextPC( .addr(address), .immd16(immd16), .immd26(immd26), .PCSrc(PCSrc), .next(nextAddress) ); wire [31:0]instruction; /* * ---------------------------------------------------------------------------------------------------------------------------------------- * 控制信号名 | 状态 '0' | 状态 '1' * ---------------------------------------------------------------------------------------------------------------------------------------- * mRD | 输出高阻态 | 读数据存储器，相关指令：lw * ---------------------------------------------------------------------------------------------------------------------------------------- */ wire romRD = 1; /* * 根据由上面程序计数器得到的指令地址从rom中取出指令 */ ROM rom( .mRD(romRD), .addr(address), .instruction(instruction) ); /* * op:指令的基本操作，成为操作码 * rs:第一源操作数寄存器 * rt:第二源操作数寄存器 * rd:存放操作结果的目的寄存器 * shamt:位移量 * funct:功能码，本次实验不需要使用到功能码 */ wire [5:0] op; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [4:0] shamt; wire [5:0] funct; /* * 将上面的变量加上前面用于分支指令的16位立即数immd16和用于跳转指令的26位立即数immd26传入译码器， * 译码器将对指令进行移码 */ Decoder decoder( .instruction(instruction), .op(op), .rs(rs), .rt(rt), .rd(rd), .funct(funct), .shamt(shamt), .immd16(immd16), .immd26(immd26) ); /* * ZERO：如果ALU运算结果结果为0，则zero=1；否则zero=0，用于计算PCSrc * SIGN：立即数符号位扩展时需要使用到SIGN * ALUScrA：算术逻辑单元的运算数A的来源，可能的值：寄存器堆，shamt * ALUScrB：算术逻辑单元的运算数B的来源，可能的值：寄存器堆，sign或zero扩展的立即数 * DBDataSrc：DBDataSrc = 0 ，来自ALU运算结果的输出；DBDataSrc = 1，来自数据存储器（Data MEM）的输出 * RegWr：判断指令是否需要将数据写入寄存器 * mRD：为1时，执行lw操作；反之，输出高阻态 * mWR：为1时，执行sw操作 * RegDst：写寄存器组寄存器的地址，可能的值：rt字段或rd字段 * ExtSel：0扩展或符号位扩展 */ wire ZERO; wire SIGN; wire ALUScrA; wire ALUScrB; wire DBDataSrc; wire RegWr; wire mRD; wire mWR; wire RegDst; wire ExtSel; wire [2:0]ALUop; // 控制单元 ControlUnit myControlUnit( .Op(op), .Funct(funct), .ZERO(ZERO), .SIGN(SIGN), .ALUScrA(ALUScrA), .ALUScrB(ALUScrB), .DBDataSrc(DBDataSrc), .RegWr(RegWr), .mRD(mRD), .mWR(mWR), .RegDst(RegDst), .ExtSel(ExtSel), .PCSrc(PCSrc), .ALUop(ALUop) ); /* * Register File：寄存器组 * ReadData1，rs寄存器数据输出端口 * ReadData2，rt寄存器数据输出端口 * WriteReg，将数据写入的寄存器端口，其地址来源rt或rd字段 * RegWriteData，写入寄存器的数据输入端口 * ALUResult，ALU运算结果，RegWriteData的来源之一，由控制单元的DBDataSrc决定 * RAMOut，RAM的输出，RegWriteData的来源之一，由控制单元的DBDataSrc决定 */ wire [31:0] ReadData1; wire [31:0] ReadData2; wire [4:0] WriteReg; assign WriteReg = RegDst == `FromRt ? rt : rd; wire [31:0] RegWriteData; wire [31:0] ALUResult; wire [31:0] RAMOut; assign RegWriteData = DBDataSrc == `FromALU ? ALUResult : RAMOut; RegFile regfile( .CLK(clk), .RST(RST), .RegWre(RegWr), .ReadReg1(rs), .ReadReg2(rt), .WriteReg(WriteReg), .WriteData(RegWriteData), .ReadData1(ReadData1), .ReadData2(ReadData2) ); // exd_immd，保存符号位扩展后的结果 wire [31:0] extend_immd; Extend extend( .immd16(immd16), .extSel(ExtSel), .exd_immd(extend_immd) ); /* * ALUa：ALU输入A * zeroExtend_shamt：ALUa可能的数据输入之一——来自移位数sa，同时，进行(zero-extend)sa，即 &#123;&#123;27&#123;0&#125;&#125;,sa&#125;，相关指令：sll * ReadData1：ALUa可能的数据输入之一，来自寄存器堆data输出，相关指令：add、sub、addi、or、and、ori、beq、bne、slti、sw、lw * ALUb：ALU输入B * extend_immd：ALUa可能的数据输入之一，来自sign或zero扩展的立即数，相关指令：addi、ori、slti、sw、lw * ReadData2：ALUa可能的数据输入之一，来自寄存器堆data输出，相关指令：add、sub、or、and、sll、beq、bne */ wire [31:0] ALUa; wire [31:0] zeroExtend_shamt; assign zeroExtend_shamt = &#123;&#123;27&#123;1'b0&#125;&#125;, shamt&#125;; assign ALUa = ALUScrA == `FromData ? ReadData1 : zeroExtend_shamt; wire [31:0] ALUb; assign ALUb = ALUScrB == `FromData ? ReadData2 : extend_immd; ALU myALU( .operation(ALUop), .regA(ALUa), .regB(ALUb), .result(ALUResult), .zero(ZERO), .sign(SIGN) ); // Data Memory：数据存储器 RAM ram( .clk(clk), .address(ALUResult), .writeData(ReadData2), .mRD(mRD), .mWR(mWR), .Dataout(RAMOut) );endmodule 三、测试 测试代码 1234567891011121314151617181920//top_tb.v`timescale 1ns/1psmodule top_tb();reg clk = 1;reg RST = 1;always begin #5; clk = ~clk;endinitial begin #1; RST = 0; #1; RST = 1;end CPU cpu( .clk(clk), .RST(RST) );endmodule FYI项目下载：SingleCycleCPU]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机组成原理与接口设计</category>
      </categories>
      <tags>
        <tag>写着玩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理与接口设计——期中课程设计：使用X86编程语言实现的迷宫游戏]]></title>
    <url>%2F%2FCOD%2FMazeGame%2F</url>
    <content type="text"><![CDATA[功能简介与实现效果一个用X86实现的迷宫游戏，首先，在进入游戏首页之后，玩家可以根据自己的喜好选择自己想要玩的难度，本游戏总共有是三个难度，Easy，Normal，Hard，分别对应三个不同难度的迷宫； 在选择了迷宫难度之后，将会刷新出一个对应难度的迷宫，在这个游戏中，玩家扮演的是一个想要逃离迷宫的小人，这个人用一个笑脸表示，只有当玩家控制角色到达迷宫的出口，即迷宫中标有 A 的位置时候，才能获得游戏的胜利；玩家将通过键盘上的W,A,S,D 键对角色进行移动，分别对应向上，左，下，右移动；当碰到障碍物的时候，角色将不能往那个方向移动； 在成功走出迷宫之后，玩家可以选择进入下一关或者是离开游戏；如果玩家已经走出最难的迷宫，那么玩家也可以选择继续游戏，重新玩一遍游戏； 程序流程图 实现过程（1）第一步，我们需要在DATA SEGMENT 中存放一些我们之后要使用的数据 首先，是将整个迷宫模型保存在MSG_EASYMAZE（简单难度），MSG_NORMALMAZE（普通难度），MSG_HARDMAZE中（困难难度），分别对应三个难度的迷宫模型（这里限于篇幅值显示了MSG_EASYMAZE，另外两个迷宫是一样的原理，具体内容可以下载最下面的源代码查看） 1234567891011MSG_EASYMAZE DB "---------------------------------------------|", 0AH, 0DH DB " | | | | | |", 0AH, 0DH DB "| |------------ |--- | | | | | | | |", 0AH, 0DH DB "| | | | | | | | | |", 0AH, 0DH DB "| |--| ---| |--|-----| |------ | |--| |", 0AH, 0DH DB "| | | | |--| | |", 0AH, 0DH DB "|--- | |-----| | ------| ------|", 0AH, 0DH DB "| | | | |--| | | |", 0AH, 0DH DB "| ------| ------| |--| | |--- |--- | |", 0AH, 0DH DB "| | | | A", 0AH, 0DH DB "|--------------------------------------------|$" 然后，是一些字符串，这些字符串将在游戏引导界面告诉玩家该如何操作: 1234567891011121314151617NEW_LINE DB 13,10,"$"MSG_WON DB "You Have Won!!! $", 0AH, 0DHMSG_NEXTLEVEL DB 13,10,"Go To The Next Level: Enter Y to the Next Level,Input Others to Exit!$",0AH, 0DH MSG_CONTINUE DB 13,10,"If Continue: Enter Y to Continue,Input Others to Exit!$",0AH, 0DH MSG_INSTRUCTION DB "WELCOME !!! $", 0AH, 0DHMSG_SETLEVEL DB "Enter the level you want to play(0 for easy,1 for normal,2 for difficulty): ",0AH, 0DHDB "Any Invalid Input Will Be Treat As 0: $",0AH, 0DHMSG_CONTROL DB "You are about to play the game, remember,you can use the w,a,s,d in the keyboard to move",0AH, 0DHDB "w for up, a for west, s for down, d for east, enter any key to play the game, have a good time!!!$",0AH, 0DH 然后是一些我们需要使用的变量： 变量名 功能 x 玩家当前的x坐标 y 玩家当前的y坐标 NextX 玩家下一步的x坐标 NextY 玩家下一步的y坐标 position 临时变量，用于取出某个位置的内容（用于判断是不是为空，如果为空，则可以移动到该位置） dirInput 临时变量，用于保存输入的移动指令,w,s,a,d difficulty 临时变量，用于保存输入的难度 player 表示玩家（打印该变量即打印玩家） direction 输入的指令（如Y表示Yes，用于判断是否继续游戏等函数） 12345678910x DB 0H ; the x-coordinate of the playery DB 0H ; the y-coordinate of the playerNextX DB 0H ; the next x-coordinate of the playerNextY DB 0H ; the next y-coordinate of the player position DB 0H ; a template variable that we use to contain the character in the positiondirInput DB 0H ; the direction you input that your player will move difficulty DW 0H player DB 01Hdirection DB 0H （2）之后我们添加进入游戏之前的引导界面代码1234567891011121314151617181920212223242526START: MOV AX, DATA MOV DS, AX MOV ES, AXINSTRUCTION: CALL CLEAN_SCREEN LEA DX, MSG_INSTRUCTION ; print the welcome CALL SHOW LEA DX, NEW_LINE CALL SHOW LEA DX, MSG_CONTROL ; print how to control the player CALL SHOW LEA DX, NEW_LINE CALL SHOW LEA DX, MSG_SETLEVEL ; choose the difficulty CALL SHOW CALL GET_INPUT MOV direction, AL CMP direction,'0' JE GAME_START ; easy game CMP direction,'1' JE GAME_START_NORMAL ; normal game CMP direction,'2' JE GAME_START_HART ; hard game CALL GAME_START ; default : easy game （3）第三步，选择对应难度之后绘制对应难度的地图，下面以easy game为例： 首先，是绘制迷宫 12345678910111213;start the game GAME_START: CALL EASYMAZE ;draw the maze CALL SET_STARTPOS ;set the start position of the character CALL PRINT_PLAYER JMP ChangePos ; Draw the easy maze EASYMAZE: CALL CLEAN_SCREEN LEA DX, MSG_EASYMAZE CALL SHOW RET 打印出地图之后，我们需要在起始位置：即迷宫的入口打印玩家： 123456789101112131415161718; Set the begin position of the playerSET_STARTPOS: MOV NextX, 0H MOV NextY, 1H MOV x, 0H MOV y, 1H MOV DL, x MOV DH, y MOV BH, 0H MOV AH, 2H INT 10H RET ; Print the player to the console PRINT_PLAYER: MOV DL, player CALL SHOW_CHARACTER RET （4）第四步，开始监听键盘输入指令，对输入的对应指令进行处理，移动玩家 监听键盘输入：w, a, s, d 123456789101112131415161718192021ChangePos: CALL GET_INPUT ; get the input MOV dirInput, AL ; case : w/W(up),a/A(left),s/S(down),d/D(right) CMP dirInput, 'W' JE MOVE_NORTH CMP dirInput, 'A' JE MOVE_WEST CMP dirInput, 'S' JE MOVE_SOUTH CMP dirInput, 'D' JE MOVE_EAST CMP dirInput, 'w' JE MOVE_NORTH CMP dirInput, 'a' JE MOVE_WEST CMP dirInput, 's' JE MOVE_SOUTH CMP dirInput, 'd' JE MOVE_EAST JMP ChangePos 根据对应的输入控制角色进行相应的移动，我们以输入了W为例，整个移动过程如下 删除原位置的字符 更新下一步的位置 判断下一步的位置是否合法 如果是，移动坐标到该位置，反之，不移动 回到ChangePos继续监听键盘输入，进行下一步移动 12345678910MOVE_NORTH: CALL REMOVE_OLDPOS ;remove the character in previous position DEC NextY CALL ISVALID_POS DEC y ;if the positon is empty, then update the position MOV DL, x MOV DH, y CALL SET_CURSOR CALL PRINT_PLAYER JMP ChangePos ; go back to the ChangePos function, to read the next input 删除原位置的字符 12345678;This function is used to remove the character in previous positionREMOVE_OLDPOS: MOV DL, x MOV DH, y CALL SET_CURSOR MOV DL, ' ' CALL SHOW_CHARACTER RET 判断新的位置是否合法： 获得新的位置里面的字符 该字符为空格，表示可以移动 不为空，进入POS_NOTEMPTY函数判断是否为 ‘ A ’，为 ‘ A ‘，获胜；反之，表示撞到了墙，不移动 123456789101112131415161718192021ISVALID_POS: MOV DL, NextX ; get the new position of the player MOV DH, NextY CALL SET_CURSOR MOV BH, 0h CALL GET_CHARACTER ; get the character in the new position MOV position, AL ; if if was empty, then we can the player to that direction CMP position, ' ' JNE POS_NOTEMPTY RET POS_NOTEMPTY: CMP position, 'A' ; if it's the EXIT, then you win!!! JE WIN MOV DL, x MOV DH, y CALL SET_CURSOR MOV NextX, DL MOV NextY, DH ; set the new position the same as the old, it means you hit the wall and can not move CALL PRINT_PLAYER JMP ChangePos ; go back to the ChangePos function, to read the next input 整个游戏过程就是不停的监听键盘输入，获得输入之后进行移动；如果此时已经离开了迷宫，则游戏成功；反之，继续监听键盘输入。 （四）逃离迷宫之后的界面 逃离迷宫后，你将会进入WIN函数，在这个函数里，你将选择是进入下一关（如果还有更高的难度的迷宫）还者是继续游戏（你已经通关所有难度的游戏了，可以重新再玩一次）： 1234567891011121314151617181920WIN: CALL CLEAN_SCREEN LEA DX, MSG_WON CALL SHOW CMP difficulty,02H ; difficulty = 02H, you have pass all the games JNE SHOW_MSG_NEXTLEVEL ; if difficulty != 02H, go to choose if go to the next level JMP EXIT_GAME ; if difficulty == 02H, go to choose if continueEXIT_GAME: LEA DX, MSG_CONTINUE ; print the instruction CALL SHOW CALL READ_INPUT CMP AL, "Y" JNE EXIT JMP GAME_START EXIT: CALL CLEAN_SCREEN MOV AX, 4C00H INT 21H （五）最后我们需要的提供一些功能函数：清屏，获得某个位置的内容，显示字符串，显示字符，设置光标的位置等1234567891011121314151617181920212223242526272829303132333435363738394041424344454647; CALL this function to print in the consoleSHOW: MOV AH, 09H INT 21H RET ; CALL this function to print a character in the consoleSHOW_CHARACTER: MOV AH, 02H INT 21H RET ;CALL this function to clean the console CLEAN_SCREEN: MOV AL, 3H MOV AH, 0H INT 10H RET ; Print the player to the console PRINT_PLAYER: MOV DL, player CALL SHOW_CHARACTER RET; Get the input from the keyboard GET_INPUT: MOV AH, 7H INT 21H RET ; Set the position of the cursorSET_CURSOR: MOV AH, 2H INT 10H RET ; Get the character in a positionGET_CHARACTER: MOV AL, 0h MOV AH, 08h INT 10H RET; Get the input READ_INPUT: MOV AH, 01 INT 21H RET 总结整个程序的运行过程就是这样，一开始比较难处理的是如何获取某个位置的字符内容，之后通过使用上面的SET_CURSOR函数和GET_CHARACTER函数就解决了；目前让我比较在意的一点就是迷宫不能做的太大，如果做的太大的话就会导致打印的时候输出很奇怪，不过目前的程序运行起来是没有问题的๑乛◡乛๑ 项目下载：Maze Game X86]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机组成原理与接口设计</category>
      </categories>
      <tags>
        <tag>写着玩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中山大学中级实训——GridWorld]]></title>
    <url>%2F%2Fgridworld%2F</url>
    <content type="text"><![CDATA[终于，๑乛◡乛๑，实训结束了 整个实训过程笔记请看： 中山大学软件工程大二中级实训——GridWorld]]></content>
      <categories>
        <category>学习笔记</category>
        <category>实训</category>
      </categories>
      <tags>
        <tag>写着玩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——（C#）Newtonsoft.Json：一种方便的解析Json字符串的方法]]></title>
    <url>%2F%2Fuwp%2FJsonParsing%2F</url>
    <content type="text"><![CDATA[功能简介之前的一篇博客现代操作系统应用开发：网络编程（一）：Json字符串和Xml字符串解析写过如何解析Json字符串，但是！！！今天发现使用Newtonsoft.Json相对于微软的Windows.Data.Json，可以更加简单的解析Json字符串。 实现过程(1）第一步，建立我们的Json对象这里使用我们上次聚合数据的Json数据，可以直接复制下面的内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&#123; "resultcode": "200", "reason": "查询成功!", "result": &#123; "sk": &#123; /*当前实况天气*/ "temp": "21", /*当前温度*/ "wind_direction": "西风", /*当前风向*/ "wind_strength": "2级", /*当前风力*/ "humidity": "4%", /*当前湿度*/ "time": "14:25" /*更新时间*/ &#125;, "today": &#123; "city": "天津", "date_y": "2014年03月21日", "week": "星期五", "temperature": "8℃~20℃", /*今日温度*/ "weather": "晴转霾", /*今日天气*/ "weather_id": &#123; /*天气唯一标识*/ "fa": "00", /*天气标识00：晴*/ "fb": "53" /*天气标识53：霾 如果fa不等于fb，说明是组合天气*/ &#125;, "wind": "西南风微风", "dressing_index": "较冷", /*穿衣指数*/ "dressing_advice": "建议着大衣、呢外套加毛衣、卫衣等服装。", /*穿衣建议*/ "uv_index": "中等", /*紫外线强度*/ "comfort_index": "",/*舒适度指数*/ "wash_index": "较适宜", /*洗车指数*/ "travel_index": "适宜", /*旅游指数*/ "exercise_index": "较适宜", /*晨练指数*/ "drying_index": ""/*干燥指数*/ &#125;, "future": [ /*未来几天天气*/ &#123; "temperature": "28℃~36℃", "weather": "晴转多云", "weather_id": &#123; "fa": "00", "fb": "01" &#125;, "wind": "南风3-4级", "week": "星期一", "date": "20140804" &#125;, &#123; "temperature": "28℃~36℃", "weather": "晴转多云", "weather_id": &#123; "fa": "00", "fb": "01" &#125;, "wind": "东南风3-4级", "week": "星期二", "date": "20140805" &#125;, &#123; "temperature": "27℃~35℃", "weather": "晴转多云", "weather_id": &#123; "fa": "00", "fb": "01" &#125;, "wind": "东南风3-4级", "week": "星期三", "date": "20140806" &#125;, &#123; "temperature": "27℃~34℃", "weather": "多云", "weather_id": &#123; "fa": "01", "fb": "01" &#125;, "wind": "东南风3-4级", "week": "星期四", "date": "20140807" &#125;, &#123; "temperature": "27℃~33℃", "weather": "多云", "weather_id": &#123; "fa": "01", "fb": "01" &#125;, "wind": "东北风4-5级", "week": "星期五", "date": "20140808" &#125;, &#123; "temperature": "26℃~33℃", "weather": "多云", "weather_id": &#123; "fa": "01", "fb": "01" &#125;, "wind": "北风4-5级", "week": "星期六", "date": "20140809" &#125;, &#123; "temperature": "26℃~33℃", "weather": "多云", "weather_id": &#123; "fa": "01", "fb": "01" &#125;, "wind": "北风4-5级", "week": "星期日", "date": "20140810" &#125; ] &#125;, "error_code": 0&#125; 然后，在项目新建一个Weather.cs的类，然后进入这个文件，在菜单栏里选择编辑——&gt;选择性粘贴——&gt;将Json粘贴为类，如下图： 之后，Visual Studio在Weather.cs文件中将自动生成下面代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// Weather.csnamespace ConsoleForNewtonsoft&#123; class Weather &#123; public class Rootobject &#123; public string resultcode &#123; get; set; &#125; public string reason &#123; get; set; &#125; public Result result &#123; get; set; &#125; public int error_code &#123; get; set; &#125; &#125; public class Result &#123; public Sk sk &#123; get; set; &#125; public Today today &#123; get; set; &#125; public Future[] future &#123; get; set; &#125; &#125; public class Sk &#123; public string temp &#123; get; set; &#125; public string wind_direction &#123; get; set; &#125; public string wind_strength &#123; get; set; &#125; public string humidity &#123; get; set; &#125; public string time &#123; get; set; &#125; &#125; public class Today &#123; public string city &#123; get; set; &#125; public string date_y &#123; get; set; &#125; public string week &#123; get; set; &#125; public string temperature &#123; get; set; &#125; public string weather &#123; get; set; &#125; public Weather_Id weather_id &#123; get; set; &#125; public string wind &#123; get; set; &#125; public string dressing_index &#123; get; set; &#125; public string dressing_advice &#123; get; set; &#125; public string uv_index &#123; get; set; &#125; public string comfort_index &#123; get; set; &#125; public string wash_index &#123; get; set; &#125; public string travel_index &#123; get; set; &#125; public string exercise_index &#123; get; set; &#125; public string drying_index &#123; get; set; &#125; &#125; public class Weather_Id &#123; public string fa &#123; get; set; &#125; public string fb &#123; get; set; &#125; &#125; public class Future &#123; public string temperature &#123; get; set; &#125; public string weather &#123; get; set; &#125; public Weather_Id1 weather_id &#123; get; set; &#125; public string wind &#123; get; set; &#125; public string week &#123; get; set; &#125; public string date &#123; get; set; &#125; &#125; public class Weather_Id1 &#123; public string fa &#123; get; set; &#125; public string fb &#123; get; set; &#125; &#125; &#125;&#125; (2) 添加Newtonsoft.Json 解决方案资源管理器 —&gt; 引用右击—&gt;管理NuGet程序包搜索Newtonsoft.Json并安装 (3) 将Json字符串转化为Json对象的函数1234567891011void ToJsonObject(string str)&#123; // 下面两句话就可以将Json字符串解析为Json对象，是不是很简单（乛◡乛） JsonSerializer json = JsonSerializer.Create(); Rootobject weather = json.Deserialize&lt;Rootobject&gt;(new JsonTextReader(new StringReader(str))); // 随便选几个值测试一下对象是不是创建成功了，相信我，成功了（乛◡乛） Console.WriteLine("resultcode: " + weather.resultcode); Console.WriteLine("reason：" + weather.reason); Console.WriteLine("result.today.temperature：" + weather.result.today.temperature);&#125; 在控制台打印出来的结果： (4）将Json对象转化为Json字符串的函数1234567891011121314// 将Json对象解析为Json字符串private static void ToJsonString()&#123; // 打开文件，下面替换为你要保存的文件路径 FileStream file = new FileStream("C:\\Users\\HP\\Desktop\\output.txt", FileMode.OpenOrCreate); TextWriter stream = new StreamWriter(file); // 下面两句话就可以将Json对象解析为Json字符串，是不是也很简单（乛◡乛） var json = JsonSerializer.Create(); json.Serialize(stream, weather); // 关闭文件流很重要，之前没有关闭流文件导致后面的数据莫名其妙地丢失了 stream.Close();&#125; 打开文件，你将看到转化完的Json字符串 FYI项目下载：ConsoleForNewtonsoft 这个项目是运行在控制台上的C# 程序，同样适用于UWP程序。 顺便推荐一个方便的在谷歌浏览器上查看Json字符串（其实还有很多其他强大的功能）的插件：WEB前端助手(FeHelper) 显示效果截图：]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：MediaElement播放进度和Slider滑块的绑定]]></title>
    <url>%2F%2Fuwp%2FMediaElementAndSlider%2F</url>
    <content type="text"><![CDATA[功能简介使用UWP提供的MediaElement控件制作一个音乐播放器，不使用MediaElement内置的传输控件，使用我们自己创建的控件Slider，将Slider滑块的位置和MediaElement的播放进度绑定，顺带一提，博客示例的音乐播放器的封面在音乐播放的时候会旋转。 注意：这里使用了转换器的知识，未使用过转换器的请看——&gt;传送门 实现效果 播放音乐 实现过程(1）创建转换器类12345678910111213141516//ProgressConverter.csnamespace MediaElementAndSlider&#123; class ProgressConverter : IValueConverter &#123; public object Convert(object value, Type targetType, object parameter, string language) &#123; return ((TimeSpan)value).TotalSeconds; &#125; public object ConvertBack(object value, Type targetType, object parameter, string language) &#123; return TimeSpan.FromSeconds((double)value); &#125; &#125;&#125; 需要注意的地方： Convert 函数的value参数的类型为TimeSpan，为保存MediaElement的播放进度的一个结构体，调用TotalSeconds 函数将返回总共播放的秒数 ConvertBack 函数的value参数的类型为double，为Slider的值，使 TimeSpan.FromSeconds((double)value)将返回一个TimeSpan对象 (2) 在MainPage.xaml中添加代码 添加需要的资源 1234&lt;!-- MainPage.xaml --&gt;&lt;Page.Resources&gt; &lt;local:ProgressConverter x:Key="progressConverter"/&gt;&lt;/Page.Resources&gt; 添加需要的控件 12345678910111213141516171819202122232425262728293031323334&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;StackPanel&gt; &lt;!-- 封面 --&gt; &lt;Ellipse x:Name="ellipse" Width="200" Height="200" RenderTransformOrigin="0.5,0.5"&gt; &lt;Ellipse.RenderTransform&gt; &lt;CompositeTransform/&gt; &lt;/Ellipse.RenderTransform&gt; &lt;Ellipse.Resources&gt; &lt;!-- Storyboard是一个动画容器，这里将通过Storyboard实现旋转 --&gt; &lt;Storyboard x:Name="EllStoryboard" RepeatBehavior="Forever"&gt; &lt;DoubleAnimation Duration="0:0:20" To="360" Storyboard.TargetProperty="(UIElement.RenderTransform).(CompositeTransform.Rotation)" Storyboard.TargetName="ellipse" d:IsOptimized="True"/&gt; &lt;/Storyboard&gt; &lt;/Ellipse.Resources&gt; &lt;!--这里用一张图片来填充这个椭圆形--&gt; &lt;Ellipse.Fill&gt; &lt;ImageBrush x:Name="picture" ImageSource="Assets/cover.jpg" /&gt; &lt;/Ellipse.Fill&gt; &lt;/Ellipse&gt; &lt;!-- Source替换为你的音乐的地址 --&gt; &lt;MediaElement x:Name="mediaSimple" Source="ms-appx:///Assets/种族假象.mp3" AutoPlay="False"&gt; &lt;/MediaElement&gt; &lt;!-- 进度条，使用progressConverter转换器 --&gt; &lt;Slider x:Name="progress" Minimum="0" Maximum="100" Value="&#123;Binding ElementName=mediaSimple,Path=Position,Converter=&#123;StaticResource progressConverter&#125;, Mode=TwoWay&#125;"&gt;&lt;/Slider&gt; &lt;/StackPanel&gt;&lt;/Grid&gt;&lt;Page.BottomAppBar&gt; &lt;CommandBar x:Name="commandBar"&gt; &lt;AppBarButton Icon="Play" Click="playClick"/&gt; &lt;AppBarButton Icon="Clear" Click="pauseClick"/&gt; &lt;AppBarButton Icon="Stop" Click="stopClick"/&gt; &lt;/CommandBar&gt; &lt;/Page.BottomAppBar&gt;&lt;/Page&gt; 需要注意的地方： Page.Resources 添加资源 Slider的Value属性实现双向绑定 (3）在MainPage.xaml.cs中添加代码12345678910111213141516171819202122/* 下面的函数都是按钮点击事件 */// 开始播放private void playClick(object sender, RoutedEventArgs e)&#123; mediaSimple.Play(); EllStoryboard.Begin(); progress.Maximum = mediaSimple.NaturalDuration.TimeSpan.TotalSeconds;&#125;// 暂停播放private void pauseClick(object sender, RoutedEventArgs e)&#123; mediaSimple.Pause(); EllStoryboard.Pause();&#125;// 停止播放，回到起始位置private void stopClick(object sender, RoutedEventArgs e)&#123; mediaSimple.Stop(); EllStoryboard.Stop();&#125; 需要注意的地方： 在开始播放的时候设置Slider的最大值 FYI项目下载：MediaElementAndSlider 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：网络编程（一）：Json字符串和Xml字符串解析]]></title>
    <url>%2F%2Fuwp%2FJsonAndXml%2F</url>
    <content type="text"><![CDATA[功能简介好久没写博客了，└༼ ಥ ᗜ ಥ ༽┘！！！ 很简单的功能：分别使用System.Xml.XmlDocument 和 Windows.Data.Json 解析并提取服务器端传来的Xml字符串和Json字符串，这里使用聚合数据API 提供的数据，Xml字符串提供12306火车票查询，Json字符串提供天气查询，示例项目将通过返回的字符串提取我们想要的数据并显示出来 实现效果 Json：天气查询 Xml：12306 火车票查询 输入错误，异常判断 实现过程(1）获得数据首先，我们需要从聚合数据中获得数据并且知道返回的数据的格式，在聚合数据上注册，申请数据（部分数据的需要收费，这里使用的天气查询和12306查询首次申请将赠送500次使用次数），将得到下面的结果： 选择一个接口，如天气查询，我们将使用并解析该接口的返回数据得到我们需要的信息，返回的Json字符串如下所示 1234567891011121314151617181920/* 聚合数据返回的Json字符串数据示例 */&#123; "resultcode": "200", "reason": "查询成功!", "result": &#123; /* 该接口返回了相当详细的数据，可以查看官网获得更多信息 * 这里省略了大部分的内容，只显示出了该次实验需要提取的数据 */ "today": &#123; "city": "天津", "date_y": "2014年03月21日", "week": "星期五", "temperature": "8℃~20℃", /*今日温度*/ "weather": "晴转霾", /*今日天气*/ "weather_id": &#123; /*天气唯一标识*/ "fa": "00", /*天气标识00：晴*/ "fb": "53" /*天气标识53：霾 如果fa不等于fb，说明是组合天气*/ &#125;, &#125;&#125; 另一个例子是火车票查询接口，这里我们通过解析Xml字符串获得我们需要的信息 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;root&gt; &lt;resultcode&gt;200&lt;/resultcode&gt; &lt;reason&gt;查询成功&lt;/reason&gt; &lt;result&gt; &lt;train_info&gt; &lt;name&gt;g4&lt;/name&gt; &lt;start&gt;上海虹桥&lt;/start&gt; &lt;end&gt;北京南&lt;/end&gt; &lt;starttime&gt;14:00&lt;/starttime&gt; &lt;endtime&gt;18:28&lt;/endtime&gt; &lt;mileage/&gt; &lt;/train_info&gt; &lt;station_list&gt; &lt;!-- 这里省略了一下这次项目没有使用的值，可以查看官网获得更多信息 --&gt; &lt;/station_list&gt; &lt;/result&gt;&lt;/root&gt; (2) 在MainPage.xaml中添加需要的控件在这里，我们添加两个文本输入框和两个按钮，用于输入我们的信息 123456789&lt;!-- MainPage.xaml --&gt;&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;StackPanel Margin="10"&gt; &lt;TextBox Header="City" Margin="10" x:Name="cityBox"&gt;&lt;/TextBox&gt; &lt;Button Content="查询天气" Click="queryWeather" Margin="10" x:Name="button"&gt;&lt;/Button&gt; &lt;TextBox Header="Train Id" Margin="10" x:Name="trainBox"&gt;&lt;/TextBox&gt; &lt;Button Content="12306火车票查询" Click="queryTrain" Margin="10"&gt;&lt;/Button&gt; &lt;/StackPanel&gt;&lt;/Grid&gt; (3）在MainPage.xaml.cs中添加代码 添加对应的成员 1234567891011//MainPage.xaml.cs/* * 以查询火车票为例， * 一般的查询链接为：http://apis.juhe.cn/train/s?name=你想要查询的火车的编号&amp;key=你申请的APPKEY * 因此根据下面的string对象，在查询时将使用：trainStr + 你想要查询的火车的编号 + trainKey */private string trainStr = "http://apis.juhe.cn/train/s?dtype=xml&amp;name=";private string weatherStr = "http://v.juhe.cn/weather/index?format=2&amp;cityname=";//App Key，唯一标识，这里需要替换为你注册申请的链接private string trainKey = "&amp;key=9ec62157b998149569d54ae25cbaa8e5";private string weatherKey = "&amp;key=0e3c2dab2c8a77f4bac1138099a812ea"; 对Json字符串进行解析（查询天气）： 123456789101112131415161718192021222324252627282930313233343536373839404142//MainPage.xaml.csprivate async void queryWeather(object sender, RoutedEventArgs e)&#123; // 根据输入得到Url链接 string url = weatherStr + cityBox.Text.Trim() + weatherKey; HttpClient httpClient = new HttpClient(); var headers = httpClient.DefaultRequestHeaders; //使用HttpClient获取数据 HttpResponseMessage response = await httpClient.GetAsync(url); // 避免中文乱码 response.EnsureSuccessStatusCode(); Byte[] getByte = await response.Content.ReadAsByteArrayAsync(); Encoding code = Encoding.GetEncoding("UTF-8"); string jsonString = code.GetString(getByte, 0, getByte.Length); // 解析Json对象 JsonObject weatherObject = JsonObject.Parse(jsonString); // 如果输入正确，返回的Json字符串的resultcode = 200 if (weatherObject.GetNamedString("resultcode").Equals("200")) &#123; //根据上面的Json字符串进行解析，得到Json字符串中嵌套的Json字符串 JsonObject skObject = JsonObject.Parse(weatherObject.GetNamedValue("result").ToString()); JsonObject todayObject = JsonObject.Parse(skObject.GetNamedValue("today").ToString()); // 使用StringBuilder，可变字符串 StringBuilder stringBuilder = new StringBuilder(); stringBuilder.Append("气温 : " + todayObject.GetNamedString("temperature")); stringBuilder.Append("\n"); stringBuilder.Append("天气 : " + todayObject.GetNamedString("weather")); stringBuilder.Append("\n"); stringBuilder.Append("风向 : " + todayObject.GetNamedString("wind")); stringBuilder.Append("\n"); MessageDialog showDialog = new Windows.UI.Popups.MessageDialog(stringBuilder.ToString()); await showDialog.ShowAsync(); &#125; else &#123; //异常判断 MessageDialog errorDialog = new Windows.UI.Popups.MessageDialog("输入错误！！！"); await errorDialog.ShowAsync(); &#125;&#125; 对Xml字符串进行解析（火车票查询）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344private async void queryTrain(object sender, RoutedEventArgs e)&#123; // 根据输入得到Url链接 string url = trainStr + trainBox.Text.Trim() + trainKey; HttpClient httpClient = new HttpClient(); var headers = httpClient.DefaultRequestHeaders; //使用HttpClient获取数据 HttpResponseMessage response = await httpClient.GetAsync(url); // 避免中文乱码 response.EnsureSuccessStatusCode(); Byte[] getByte = await response.Content.ReadAsByteArrayAsync(); Encoding code = Encoding.GetEncoding("UTF-8"); string xmlString = code.GetString(getByte, 0, getByte.Length); // 根据返回的Xml字符串创建Xml对象 XmlDocument doc = new XmlDocument(); doc.LoadXml(xmlString); XmlNode root = doc.DocumentElement; // 如果输入正确，返回的Json字符串的resultcode = 200 if (doc.GetElementsByTagName("resultcode")[0].InnerText.Equals("200")) &#123; //根据上面的Xml字符串进行解析 XmlNodeList child = doc.GetElementsByTagName("train_info")[0].ChildNodes; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.Append("车次 : " + child[0].InnerText); stringBuilder.Append("\n"); stringBuilder.Append("出发站 : " + child[1].InnerText); stringBuilder.Append("\n"); stringBuilder.Append("到达站 : " + child[2].InnerText); stringBuilder.Append("\n"); stringBuilder.Append("出发时间 : " + child[3].InnerText); stringBuilder.Append("\n"); stringBuilder.Append("到达时间 : " + child[4].InnerText); stringBuilder.Append("\n"); MessageDialog showDialog = new Windows.UI.Popups.MessageDialog(stringBuilder.ToString()); await showDialog.ShowAsync(); &#125; else &#123; MessageDialog errorDialog = new Windows.UI.Popups.MessageDialog("输入错误！！！"); await errorDialog.ShowAsync(); &#125; 需要注意的地方： 根据自己注册和申请的接口修改对应的Url 和 AppKey 使用UTF-8避免中文乱码 使用JsonObject解析Json字符串内嵌的Json字符串，提取我们想要的信息 使用XmlDocument 解析Xml字符串 总结关于Json字符串和Xml字符串的解析，可以查看微软官方文档获取更加深入的理解 ：JsonObject Class，XmlDocument Class 关于UWP网络编程，解析Json字符串和Xml字符串只是冰山一角，有空的话，将会补充其他一些关于网络编程的内容（才怪） FYI项目下载：JsonAndXmlSample 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥) 补充另一种更加简单的Json字符串解析方法：Newtonsoft.Json]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——SQLite数据库实现数据持久化]]></title>
    <url>%2F%2Fuwp%2FSQLiteSample%2F</url>
    <content type="text"><![CDATA[功能简介利用SQLite数据库实现数据的持久化，以及对数据项的增、删、改、查，使用SQLite Expert查看数据库内容；博客示例项目包括一个MainPage，MainPage左边有一个ListView，用于显示数据库里的所有数据；右边包括一个搜索界面和修改界面，可以用于对数据库里的内容进行搜索和更新/添加新的数据项； 博客示例项目涉及到一些其他的内容，请确保你对下面内容有所了解再使用（可以参考链接的博客）： LocalFolder SQLite数据库的使用 双向数据绑定 实现效果 主界面 数据库保存在LocalFolder中 使用SQLite Expert查看数据库的内容 对数据库内容进行更新 对数据库内容进行搜索 实现过程(1）环境配置 将SQLite包含到应用包内：工具—&gt;拓展和更新—&gt;联机—&gt;搜索SQLitefor Univeral Windows Platform—&gt;安装 右击项目 “引用” &gt;&gt; 选择 “添加引用” &gt;&gt; 在弹出的窗口左侧栏选择 “Universal Windows” “扩展” &gt;&gt;选择“SQLite for Universal Windows Platform后确定 在引用右键管理NuGet程序包搜索SQLitePCL并安装 最终效果 (2) 新建类DBServiceDBService类是我们用于数据库管理的类，所有对数据库的操作都要通过DBService来进行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123//DBService.csnamespace SQLiteSample&#123; class DBService &#123; public DBService() &#123; //建立连接，如果MySQLite.db不存在，则会新建MySQLite.db conn = new SQLiteConnection("MySQLite.db"); //获取表，如果Items表不存在，则新建表Items string sql = @"CREATE TABLE IF NOT EXISTS ITEMS( ID INTEGER PRIMARY KEY NOT NULL, TITLE VARCHAR(50), DETAIL VARCHAR(200) );"; using (var statement = conn.Prepare(sql)) &#123; statement.Step(); &#125; &#125; private SQLiteConnection conn; //一些需要的SQL语句 private String SQL_DELETE = "DELETE FROM ITEMS" + " WHERE ID = ?"; private String SQL_UPDATE = "UPDATE ITEMS" + " SET TITLE = ? , DETAIL = ? WHERE ID = ?"; private String SQL_INSERT = "INSERT INTO ITEMS (TITLE,DETAIL)" + " VALUES(?,?);"; private String SQL_SELECT_ALL = "SELECT * FROM ITEMS"; private String SQL_QUERY = "SELECT * FROM ITEMS WHERE TITLE LIKE (?) OR DETAIL LIKE (?);"; private String SQL_GETID = "SELECT ID FROM ITEMS WHERE TITLE = (?) OR DETAIL = (?);"; //初始化，获得本地数据库中的所有Item internal void Initialize(ObservableCollection&lt;Item&gt; allItems) &#123; //使用SQL_SELECT_ALL语句获得所有的内容 using (var statement = conn.Prepare(SQL_SELECT_ALL)) &#123; //statement.Step()将依次获得每一行的结果 while (SQLiteResult.ROW == statement.Step()) &#123; int id = int.Parse(statement[0].ToString()); string title = (string)statement[1]; string detail = (string)statement[2]; allItems.Add(new Item(id, title, detail)); &#125; &#125; &#125; //增 internal int CreateItem(Item item) &#123; //往数据库中添加数据 using (var statement = conn.Prepare(SQL_INSERT)) &#123; //这里的Bind会依次替换掉上面语句中的问号 statement.Bind(1, item.Title); statement.Bind(2, item.Detail); statement.Step(); &#125; /* * 用于得到之前添加的数据的Id，其实这里的操作不太规范，因为通过title和detail可能相同 * 不过这里只是为了演示如何使用数据库，就不要太在意这个了，（乛◡乛） */ using (var statement = conn.Prepare(SQL_GETID)) &#123; statement.Bind(1, item.Title); statement.Bind(2, item.Detail); if (SQLiteResult.ROW == statement.Step()) &#123; return int.Parse(statement[0].ToString()); &#125; &#125; return 0; &#125; //更新 internal void UpdateItem(Item item) &#123; using (var statement = conn.Prepare(SQL_UPDATE)) &#123; statement.Bind(1, item.Title); statement.Bind(2, item.Detail); statement.Bind(3, item.Id); statement.Step(); &#125; &#125; //查 internal async void queryItem(string text) &#123; //StringBuilder与string的差别是一个可变字符串，在使用上和String差不多 StringBuilder strB = new StringBuilder(); using (var statement = conn.Prepare(SQL_QUERY)) &#123; string key = "%" + text + "%"; statement.Bind(1, key); statement.Bind(2, key); while (SQLiteResult.ROW == statement.Step()) &#123; strB.Append("Title: "); strB.Append(statement[1].ToString()); strB.Append(" Detail: "); strB.Append(statement[2].ToString()); strB.Append("\n"); &#125; &#125; MessageDialog searchDialog = new Windows.UI.Popups.MessageDialog(strB.ToString()); await searchDialog.ShowAsync(); &#125; //删 internal void DeleteItem(int id) &#123; using (var statement = conn.Prepare(SQL_DELETE)) &#123; statement.Bind(1, id); statement.Step(); &#125; &#125; &#125;&#125; 需要注意的地方： 在构造函数中连接数据库 预先声明的SQL语句 statement.Bind()将对SQL里的值进行添值 statement.Step()在在数据库中执行该语句 (3) 新建Item类 这个类的内容没什么重要的，Item中有三个属性，一个title，一个detail，一个id，对应数据库中一行中的数据；Item类只是为了示例需要，由于篇幅关系，这部分省略，具体代码可以下载下面的示例项目 (4) 在MainPage.xaml中添加控件 由于篇幅关系，这部分省略，具体代码可以下载下面的示例项目 (5）在MainPage.xaml.cs的构造函数上添加代码首先，我们需要添加一个DBServie对象 1private DBService itemDBService = new DBService(); 然后针对需要只用对应的函数 12345678910//列表项初始化itemDBService.Initialize(allItems);//增itemDBService.CreateItem(rightItem);//删：item.Id为Primary KeyitemDBService.DeleteItem(item.Id);//查：Query为MainPage的一个文本框，Query.Text得到查询的输入内容itemDBService.queryItem(Query.Text);//改itemDBService.UpdateItem(rightItem); 由于篇幅关系，这部分省略，具体代码可以下载下面的示例项目 总结整个项目最重要的就是第一步环境配置和第二步DBService类代码的编写，其它的地方就可以通过调用DBService的函数连接数据库啦； FYI项目下载：SQLiteSample 运行前首先需要按上面实现过程的第一步配置环境！！！ 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——LiveTileSample：动态磁贴]]></title>
    <url>%2F%2Fuwp%2FLiveTileSample%2F</url>
    <content type="text"><![CDATA[功能简介动态磁贴是UWP的一项新功能，具体效果如下，不了解UWP动态磁贴的可以看微软的官方介绍（传送门） 博客示例包括一个MainPage，如下图所示，包括一个Image控件和两个文本框（可以用于输入标题和内容），两个按钮，一个可以更改图片，一个可以添加磁贴； 对于你新建的磁贴，首先，你需要把你的程序拖动到右边（如下面的视频所示），或者右键选择固定到开始屏幕；你可以添加多个磁贴实现滚动效果，但是UWP的磁贴最多只会保存你最后添加的5个磁贴； 实现效果 实现过程(1）添加引用Microsoft.Toolkit.Uwp.Notifications 在引用右键管理NuGet程序包搜索Microsoft.Toolkit.Uwp.Notifications并安装 (2）在App.xaml.cs的构造函数中添加代码12345678910//App.xaml.cspublic App()&#123; this.InitializeComponent(); this.Suspending += OnSuspending; // 每次启动的时候要清空队列 TileUpdateManager.CreateTileUpdaterForApplication().Clear(); // 实现通知循环 TileUpdateManager.CreateTileUpdaterForApplication().EnableNotificationQueue(true); &#125; 需要注意的地方： TileUpdateManager.CreateTileUpdaterForApplication().Clear()； TileUpdateManager.CreateTileUpdaterForApplication().EnableNotificationQueue(true); (3) 新建类LiveTileService12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//LiveTileService.cspublic class LiveTileService&#123; //添加动态磁贴，title为磁贴的标题，detail为磁贴的内容，source为背景图片 public void AddTile(string title, string detail, string source) &#123; //得到磁贴的对象 TileContent content = CreateTileContent(title, detail, source); var notification = new TileNotification(content.GetXml()); //添加到磁贴的队列 TileUpdateManager.CreateTileUpdaterForApplication().Update(notification); &#125; //创建磁贴对象并返回 private TileContent CreateTileContent(string title, string detail, string source) &#123; return new TileContent() &#123; Visual = new TileVisual() &#123; //这里限于篇幅只写了TileMedium，其实还有TileLarge和TileMedium,TileWide,对应不同磁贴的大小 TileMedium = new TileBinding() &#123; Content = new TileBindingContentAdaptive() &#123; Children = &#123; new AdaptiveText() &#123; Text = title,//设置标题 HintStyle = AdaptiveTextStyle.Title &#125;, new AdaptiveText() &#123; Text = detail,//设置内容 HintStyle = AdaptiveTextStyle.Subtitle &#125; &#125;, BackgroundImage = new TileBackgroundImage() &#123; Source = source //设置背景图片 &#125; &#125; &#125; &#125; &#125;; &#125;&#125; 需要注意的地方： AddTile 为添加磁贴的函数 CreateTileContent中新建TileContent时注意Content不能少 (4) 在MainPage.xaml中添加控件12345678910111213//MainPage.xaml&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;StackPanel&gt; &lt;!-- Image的Source指向的是我的Assets文件夹中的图片，在你的代码中需要对此处进行更改 --&gt; &lt;Image x:Name="MyImage" Source="ms-appx:///Assets/spider.jpg" Width="280" Height="280"&gt;&lt;/Image&gt; &lt;TextBlock Text="标题" HorizontalAlignment="Center" Margin="5"&gt;&lt;/TextBlock&gt; &lt;TextBox x:Name="MyTitle" Width="380" Margin="5"&gt;&lt;/TextBox&gt; &lt;TextBlock Text="内容" HorizontalAlignment="Center" Margin="5"&gt;&lt;/TextBlock&gt; &lt;TextBox x:Name="MyDetail" Width="380" Height="50" TextWrapping="Wrap" Margin="5"&gt;&lt;/TextBox&gt; &lt;Button Content="更改图片" Click="ChangeImage" HorizontalAlignment="Center" Margin="5"&gt;&lt;/Button&gt; &lt;Button Content="添加磁贴" Click="AddTile" HorizontalAlignment="Center" Margin="5"&gt;&lt;/Button&gt; &lt;/StackPanel&gt;&lt;/Grid&gt; (4）在MainPage.xaml.cs文件中添加代码1234567891011121314151617181920212223242526272829303132333435363738394041424344public sealed partial class MainPage : Page&#123; //新建LiveTileService对象 private LiveTileService liveTileService; //保存图片路径，添加磁贴时将使用该图片路径 private string source; public MainPage() &#123; liveTileService = new LiveTileService(); //设置默认值 source = "ms-appx:///Assets/spider.jpg"; this.InitializeComponent(); &#125; private void AddTile(object sender, RoutedEventArgs e) &#123; //添加磁贴 liveTileService.AddTile(MyTitle.Text, MyDetail.Text, source); &#125; private async void ChangeImage(object sender, RoutedEventArgs e) &#123; //选取图片 FileOpenPicker openPicker = new FileOpenPicker(); openPicker.FileTypeFilter.Add(".jpg"); StorageFile file = await openPicker.PickSingleFileAsync(); if (file != null) &#123; //设置Image为选择的图片 BitmapImage bitmap = new BitmapImage(); using (var stream = await file.OpenAsync(Windows.Storage.FileAccessMode.Read)) &#123; bitmap.SetSource(stream); &#125; MyImage.Source = bitmap; //将图片保存在LocalFolder StorageFolder localFolder = ApplicationData.Current.LocalFolder; StorageFile fileCopy = await file.CopyAsync(localFolder, file.Name, NameCollisionOption.ReplaceExisting); &#125; source = "ms-appdata:///local/" + file.Name; &#125; &#125; 需要注意的地方： source默认值的设置 每次上传图片后需要保存到LocalFolder，添加磁贴时磁贴才能通过Source读取图片，关于文件存储的问题可以参考博客UWP——文件管理（二） FYI项目下载：LiveTileSample 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——UI共享：DataTransferManager]]></title>
    <url>%2F%2Fuwp%2FShowShareUI%2F</url>
    <content type="text"><![CDATA[功能简介使用DataTransferManager的ShowShareUI()功能，实现界面共享 示例项目有一个页面MainPage，页面内只有一个按钮，点击按钮即发生共享界面功能 实现效果 点击按钮 选择其中的邮件 实现过程(1）在MainPage.xaml中添加一个按钮并设置相应事件123&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;Button Content="ShareUI" Click="Button_Click" HorizontalAlignment="Center"&gt;&lt;/Button&gt;&lt;/Grid&gt; (2) 在MainPage.xaml.cs文件中添加代码123456789101112131415161718192021222324252627282930namespace ShowShareUISample&#123; public sealed partial class MainPage : Page &#123; public MainPage() &#123; this.InitializeComponent(); //使ShareRequested函数在共享操作时发生 DataTransferManager.GetForCurrentView().DataRequested += ShareRequested; &#125; private void Button_Click(object sender, RoutedEventArgs e) &#123; //启动共享 DataTransferManager.ShowShareUI(); &#125; //设置想要共享的内容 private void ShareRequested(DataTransferManager sender, DataRequestedEventArgs args) &#123; var deferral = args.Request.GetDeferral(); DataRequest request = args.Request; request.Data.Properties.Title = "ShareUISample"; request.Data.SetText("Description：" + "This is a line from ShareUISample. Welcome to learn UWP."); //flash.jpg是示例代码中Asssets文件夹中的图片，可以将其改为你自己的图片 request.Data.SetBitmap(RandomAccessStreamReference.CreateFromUri(new Uri("ms-appx:///Assets/flash.jpg"))); deferral.Complete(); &#125; &#125;&#125; 需要注意的地方： 在构造函数中绑定方法 在ShareRequested中添加共享的内容（Title和Text是必须的） FYI项目下载：ShowShareUISample 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——文件管理（二）：FileManagement]]></title>
    <url>%2F%2Fuwp%2FFileManagement%2F</url>
    <content type="text"><![CDATA[背景简介我们的UWP程序想要读写本地的文件的时候，往往会遇到权限问题，这里存在着两个解决方法： 第一，电脑上的KnownFolder允许UWP程序直接访问；这里的KnowFolder指的是下面图片中的文件夹： 关于这种方法可以参考第一篇博客，本片博客将主要介绍第二中方法 第二，UWP程序启动时生成的local，temp，roaming（漫游）文件夹，程序对这三个文件夹也具有直接访问权限；当需要访问这些文件夹是，需要在添加ms-appdata:///前缀，如 文件夹 前缀 local ms-appdata:///local/ roaming ms-appdata:///roaming/ temp ms-appdata:///temp/ 当需要获取local文件夹中的AppConfig.xml文件时，可以使用下面的代码： 1var file = await Windows.StorageFile.GetFileFromApplicationUriAsync(new Uri("ms-appdata:///local/AppConfig.xml")); 至于这些文件夹的路径在哪里，我们可以通过下面的代码找到： 12StorageFolder localFolder = ApplicationData.Current.LocalFolder;Debug.WriteLine(localFolder.Path); 这是程序自动生成的一个目录，每个人的路径应该都不一样 功能简介博客示例代码有一个页面MainPage，MainPage里有一个Image控件和一个按钮，点击按钮，将可以从本地选择图片，选好图片后Image将更新，同时该图片将被复制到程序的local文件夹中（如何得到local文件夹的路径看上面） 实现效果 程序启动时 选择一张图片 在本地的local文件夹中 实现过程(1） 在MainPage.xaml添加控件123456&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;StackPanel&gt; &lt;Image x:Name="MyImage" Source="/Assets/spider.jpg" Width="380" Height="520"&gt;&lt;/Image&gt; &lt;Button Content="Pick The Image" Click="PickImage" HorizontalAlignment="Center" Margin="10"&gt;&lt;/Button&gt; &lt;/StackPanel&gt;&lt;/Grid&gt; (2) 在MainPage.xaml.cs中添加代码123456789101112131415161718192021222324252627282930313233namespace FileManagementSample&#123; public sealed partial class MainPage : Page &#123; private StorageFile file; public MainPage() &#123; this.InitializeComponent(); &#125; private async void PickImage(object sender, RoutedEventArgs e) &#123; //选取图片 FileOpenPicker openPicker = new FileOpenPicker(); openPicker.FileTypeFilter.Add(".jpg"); StorageFile Pickfile = await openPicker.PickSingleFileAsync(); if (Pickfile != null) &#123; //设置Image为选择的图片 BitmapImage bitmap = new BitmapImage(); using (var stream = await Pickfile.OpenAsync(Windows.Storage.FileAccessMode.Read)) &#123; bitmap.SetSource(stream); &#125; MyImage.Source = bitmap; //将图片保存在LocalFolder StorageFolder localFolder = ApplicationData.Current.LocalFolder; StorageFile fileCopy = await Pickfile.CopyAsync(localFolder, Pickfile.Name, NameCollisionOption.ReplaceExisting); &#125; &#125; &#125;&#125; 需要注意的地方： 通过ApplicationData.Current.LocalFolder获得LocalFolder 总结整个项目其实是相当简单的，在将文件保存在LocalFolder后，我们就可以通过添加上面提到的前缀访问LocalFolder里的文件了，比如说我们代码中保存的图片，可以通过下面的代码访问： 123456789//imagename替换为图片名，如博客的示例代码，imagename将为spider2.jpgvar uri = new System.Uri("ms-appdata:///local/" + imagename);file = await Windows.Storage.StorageFile.GetFileFromApplicationUriAsync(uri);BitmapImage bitmap = new BitmapImage();using (var stream = await file.OpenAsync(Windows.Storage.FileAccessMode.Read))&#123; bitmap.SetSource(stream);&#125;MyImage.Source = bitmap; FYI项目下载：FileManagementSample 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——文件管理（一）：KnownFolder]]></title>
    <url>%2F%2Fuwp%2FKnownFolder%2F</url>
    <content type="text"><![CDATA[功能简介我们的UWP程序想要读写本地的文件的时候，往往会遇到权限问题，这里存在着两个解决方法： 第一，电脑上的KnownFolder允许UWP程序直接访问，这篇博客将接受借助KnownFolder读取和保存图片；这里的KnowFolder指的是下面图片中的文件夹： 第二，UWP程序启动时生成的local，temp，roaming（漫游）文件夹，程序对这三个文件夹也具有直接访问权限（可以参考下一篇博客UWP——文件管理（二））; 博客的示例程序将使用第一种方法，MainPage里有一个Image控件和一个Button控件，当启动程序的时候，Image控件将会进入KnownFolder中的图片文件夹，选中其中的图片（如示例图的detective978.jpg）初始化Image；点击按钮，会将Image的图片保存在KnownFolder的视频文件夹 实现效果 图片文件夹的内容 启动程序后Image控件读取图片文件夹的内容 点击按钮后Image的图片保存到视频文件夹中 实现过程(1）设置Package.appxmanifest文件在解决方案资源管理器中找到Package.appxmanifest文件，点击打开，选择其中的功能，这里可以对UWP应用的各种功能提供权限，我们在图片库和视频库上打勾 (2) 在MainPage.xaml添加控件1234567&lt;!-- MainPage.xaml --&gt;&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;StackPanel&gt; &lt;Image x:Name="MyImage" Width="400" Height="600"&gt;&lt;/Image&gt; &lt;Button Content="Save The Image" Click="Button_Click"&gt;&lt;/Button&gt; &lt;/StackPanel&gt;&lt;/Grid&gt; (3）在MainPage.xaml.cs的构造函数上添加代码12345678910111213141516171819202122232425262728293031323334353637//MainPage.xaml.csnamespace KnownFolderSample&#123; public sealed partial class MainPage : Page &#123; //用于保存图片 StorageFile file; public MainPage() &#123; this.InitializeComponent(); SetImageSource(); &#125; //读取图片库里的图片并赋值给Image private async void SetImageSource() &#123; StorageFolder storageFolder = await KnownFolders.GetFolderForUserAsync(null, KnownFolderId.PicturesLibrary); file = await storageFolder.GetFileAsync("detective978.jpg"); //将图片赋给右侧的Image if (file != null) &#123; BitmapImage bitmap = new BitmapImage(); using (var stream = await file.OpenAsync(Windows.Storage.FileAccessMode.Read)) &#123; bitmap.SetSource(stream); &#125; MyImage.Source = bitmap; &#125; &#125; //点击按钮将图片保存在视频库里 private async void Button_Click(object sender, RoutedEventArgs e) &#123; StorageFolder storageFolder = await KnownFolders.GetFolderForUserAsync(null, KnownFolderId.VideosLibrary); await file.CopyAsync(storageFolder, "KnownFolder.jpg", NameCollisionOption.ReplaceExisting); &#125; &#125;&#125; 总结整个项目其实是相当简单的，需要注意的地方有两个： 在开始的时候在Package.appxmanifest中提供权限 使用KnownFolders.GetFolderForUserAsync获得文件夹 FYI项目下载：KnownFolderSample 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——onSuspend：挂起并关闭]]></title>
    <url>%2F%2Fuwp%2FonSuspend%2F</url>
    <content type="text"><![CDATA[功能简介MainPage里面有一个Image控件和文本框控件，可以更改图片和在文本框中输入内容，Debug模式下选择生命周期事件中的挂起并关闭，重新打开之后还原之前图片的内容和文本框的内容 实现效果 启动 更改内容 挂起并关闭后再启动 实现过程(1）修改App.xaml.cs文件 在类App中添加一个变量，用于判断是否处于挂起状态 12//App.cspublic bool isSuspend = false; 修改OnSuspending函数 123456789private void OnSuspending(object sender, SuspendingEventArgs e)&#123; this.isSuspend = true; var deferral = e.SuspendingOperation.GetDeferral(); //保存应用程序状态并停止任何后台活动 Frame frameState = Window.Current.Content as Frame; ApplicationData.Current.LocalSettings.Values["Navigation"] = frameState.GetNavigationState(); deferral.Complete();&#125; 在OnLaunched函数中添加代码 1234567891011121314151617181920212223protected override void OnLaunched(LaunchActivatedEventArgs e)&#123; Frame rootFrame = Window.Current.Content as Frame; if (rootFrame == null) &#123; rootFrame = new Frame(); rootFrame.NavigationFailed += OnNavigationFailed; if (e.PreviousExecutionState == ApplicationExecutionState.Terminated) &#123;//添加的代码 rootFrame.SetNavigationState((string)ApplicationData.Current.LocalSettings.Values["Navigation"]); &#125; Window.Current.Content = rootFrame; &#125; if (e.PrelaunchActivated == false) &#123; if (rootFrame.Content == null) &#123; rootFrame.Navigate(typeof(MainPage), e.Arguments); &#125; Window.Current.Activate(); &#125;&#125; (2) 在MainPage.xaml中添加控件1234567&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;StackPanel&gt; &lt;Image Source="/Assets/RedHood.jpg"&gt;&lt;/Image&gt; &lt;TextBox Text="This is the default content"&gt;&lt;/TextBox&gt; &lt;Button Content="PickPicture" Click="ChangeImage"&gt;&lt;/Button&gt; &lt;/StackPanel&gt;&lt;/Grid&gt; (3）在MainPage.xaml.cs中添加代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697namespace onSuspendSample&#123; public sealed partial class MainPage : Page &#123; //source和Content用于保存Image控件的Source和文本框的内容 private string source = ""; private string content = ""; //prefix为LocalFolder的使用前缀 private string prefix = "ms-appdata:///local/"; public MainPage() &#123; this.InitializeComponent(); &#125; //改变图片的按钮点击事件 private async void ChangeImage(object sender, RoutedEventArgs e) &#123; //挑选图片 var openPicker = new Windows.Storage.Pickers.FileOpenPicker(); openPicker.FileTypeFilter.Add(".jpg"); StorageFile file = await openPicker.PickSingleFileAsync(); //保存图片到LocalFolder Windows.Storage.StorageFolder localFolder = Windows.Storage.ApplicationData.Current.LocalFolder; StorageFile fileCopy = await file.CopyAsync(localFolder, file.Name, NameCollisionOption.ReplaceExisting); BitmapImage bitmap = new BitmapImage(); using (var stream = await fileCopy.OpenAsync(Windows.Storage.FileAccessMode.Read)) &#123; bitmap.SetSource(stream); &#125; //source保存图片路径，挂起后重新打开将使用这个值进行还原 source = prefix + file.Name; //设置图片控件的Image属性 MyImage.Source = bitmap; &#125; //进入MainPage时调用 protected override void OnNavigatedTo(NavigationEventArgs e) &#123; //判断是第一次打开还是挂起后打开 if (e.NavigationMode == NavigationMode.New) &#123; ApplicationData.Current.LocalSettings.Values.Remove("MainPage"); &#125; else &#123; if (ApplicationData.Current.LocalSettings.Values.ContainsKey("MainPage")) &#123; //还原值 ApplicationDataCompositeValue composite = ApplicationData.Current.LocalSettings.Values["MainPage"] as ApplicationDataCompositeValue; source = composite["source"].ToString(); content = composite["content"].ToString(); ApplicationData.Current.LocalSettings.Values.Remove("MainPage"); &#125; //更新控件 UpdateWidget(); &#125; &#125; protected override void OnNavigatedFrom(NavigationEventArgs e) &#123; /* * OnNavigatedFrom在离开MainPage是会被调用，有可能是跳转到其他的页面，也有可能是挂起 * suspending判断是否为挂起 */ bool suspending = ((App)App.Current).isSuspend; if (suspending) &#123; //如果是，将source，content的值保存下来，下次再打开的时候还原 ApplicationDataCompositeValue composite = new ApplicationDataCompositeValue(); composite["source"] = source; composite["content"] = MyTextBox.Text; ApplicationData.Current.LocalSettings.Values["MainPage"] = composite; &#125; &#125; //更新控件 private async void UpdateWidget() &#123; //根据路径获取图片 var uri = new System.Uri(source); StorageFile file = await StorageFile.GetFileFromApplicationUriAsync(uri); BitmapImage bitmap = new BitmapImage(); using (var stream = await file.OpenAsync(Windows.Storage.FileAccessMode.Read)) &#123; bitmap.SetSource(stream); &#125; MyImage.Source = bitmap; MyTextBox.Text = content; &#125; &#125;&#125; 需要注意的地方： 代码中LocalFolder的内容涉及UWP的文件操作，可以参考另一篇博客：UWP—文件操作 更改Image的图片后要更新source的值 OnNavigatedFrom函数在离开MainPage时调用，该函数中添加的代码是为了保存控件的属性值 OnNavigatedTo函数在进入MainPage时调用，如果是在挂起后重新进入MainPage，该函数将使用OnNavigatedFrom中保存的值还原Source和content，然后再通过UpdateWidget函数更新控件的属性值 总结整个挂起并还原的功能最重要的就是两个部分： App.cs中添加代码是程序状态可以保存 在MainPage的OnNavigatedFrom函数中保存想要保存的值，在OnNavigatedTo函数中提取之前保存的值 Tips需要注意的是，目前UWP挂起后能保存的数据必须是能序列化的， 即C#的基本类型，因此在页面跳转的时候不能传递自定义的类对象（其实就算不使用挂起功能的话也不推荐在页面跳转中传递自定义的对象，最好只传递基本类型，如果真的要让两个页面共用一个自定义的类对象的话，可以使用单例模式啊V●ᴥ●V） FYI项目下载：onSuspendSample 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——DataBinding（三）：双向数据绑定]]></title>
    <url>%2F%2Fuwp%2FTwoWayDataBinding%2F</url>
    <content type="text"><![CDATA[功能简介示例项目有个一页面MainPage，实现MainPage里的数据双向绑定到界面（ListView）上，在界面的操作对数据模型的修改能实时反映到数据；而数据的变更能实时展现到界面。 实现效果 Array到ListView的数据绑定 ListView到Array的绑定 实现过程(1）新建一个类Item.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//Item.csnamespace TwoWayDataBinding&#123; /* * Item是我们自定义的一个类型，包含三个属性，对应三个控件的属性 * Content --&gt; 文本框的内容 * Source --&gt; Image的Source * Ischecked --&gt; Checkbox的checked * 这里继承了接口INotifyPropertyChanged，当客户端某一属性值发生更改时，发出通知 */ public class Item : INotifyPropertyChanged &#123; private string _content; private string _source; private bool _ischecked; public string Content &#123; get =&gt; _content; set &#123; _content = value; OnPropertyChanged("Content") ; &#125; &#125; public string Source &#123; get =&gt; _source; set &#123; _source = value; OnPropertyChanged("Source"); &#125; &#125; public bool Ischecked &#123; get =&gt; _ischecked; set &#123; _ischecked = value; OnPropertyChanged("Ischecked"); &#125; &#125; public Item(string content, string source, bool ischecked) &#123; this._content = content; this._source = source; this._ischecked = ischecked; &#125; //显示实现接口，实现数据绑定动态更新 public event PropertyChangedEventHandler PropertyChanged; protected void OnPropertyChanged(string propertyName = "") &#123; PropertyChangedEventHandler handler = this.PropertyChanged; if (handler != null) &#123; handler(this, new PropertyChangedEventArgs(propertyName)); &#125; &#125; &#125;&#125; 需要注意的地方： 与上一篇博客相比，对Item类的每一个属性添加了set方法，因为对ListView的修改将导致Item的实时更新，所以需要set方法 继承接口INotifyPropertyChanged set方法中的OnPropertyChanged函数，是为了发送通知，实现数据绑定动态更新 (2) 新建一个类CheckBoxConverter作为转换器1234567891011121314151617181920212223242526272829303132333435//CheckBoxConverter.csnamespace TwoWayDataBinding&#123; /* * 转化器，将布尔值转化为Checkbox的IsChecked属性 */ public class CheckBoxConverter : IValueConverter &#123; public object Convert(object value, Type targetType, object parameter, string language) &#123; bool? isChecked = value as bool?; if (isChecked == null || isChecked == false) &#123; return false; &#125; else &#123; return true; &#125; &#125; public object ConvertBack(object value, Type targetType, object parameter, string language) &#123; bool? isChecked = value as bool?; if (isChecked == null || isChecked == false) &#123; return false; &#125; else &#123; return true; &#125; &#125; &#125;&#125; 关于转换器可以看上一篇博客 (3）在MainPage.xaml中添加控件和声明资源文件12345678910111213141516171819202122232425262728293031323334&lt;!-- MainPage.xaml --&gt;&lt;!-- 声明资源文件 --&gt;&lt;Page.Resources&gt; &lt;local:CheckBoxConverter x:Key="ConvertCheck"&gt;&lt;/local:CheckBoxConverter&gt;&lt;/Page.Resources&gt;&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;!-- ItemSource用于指定ListView的数据源 --&gt; &lt;ListView Margin="20,20,50,20" ItemsSource="&#123;x:Bind Array&#125;"&gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate x:DataType="local:Item"&gt; &lt;RelativePanel&gt; &lt;!-- Source="&#123;x:Bind Ischecked&#125;"指定CheckBox是否被选中 --&gt; &lt;CheckBox IsChecked="&#123;x:Bind Ischecked,Converter=&#123;StaticResource ConvertCheck&#125;,Mode=TwoWay&#125;" HorizontalAlignment="Left" VerticalAlignment="Top" Margin="10,10,0,0"&gt;&lt;/CheckBox&gt; &lt;Grid Width="90" x:Name="Space"&gt;&lt;/Grid&gt; &lt;!-- Source="&#123;x:Bind Source&#125;"指定Image图片控件的图片源 --&gt; &lt;Image Source="&#123;x:Bind Source,Mode=OneWay&#125;" HorizontalAlignment="Left" Height="40" Margin="50,10,0,0" VerticalAlignment="Top" Width="40"&gt;&lt;/Image&gt; &lt;!-- Text="&#123;x:Bind Content&#125;"指定文本块的内容，Source和Content都是Item的属性 --&gt; &lt;TextBox Text="&#123;x:Bind Content,Mode=TwoWay&#125;" RelativePanel.RightOf="Space" VerticalAlignment="Top" HorizontalAlignment="Left" FontSize="20" Margin="10,12,0,0"&gt;&lt;/TextBox&gt; &lt;/RelativePanel&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt;&lt;/Grid&gt;&lt;!-- 点击Add按钮将往Array中添加元素 点击ShowResults按钮将打印Array的内容 --&gt;&lt;Page.BottomAppBar&gt; &lt;CommandBar&gt; &lt;AppBarButton Icon="Add" Click="AddButton_Click"/&gt; &lt;AppBarButton Icon="ShowResults" Click="ShowButton_Click"/&gt; &lt;/CommandBar&gt;&lt;/Page.BottomAppBar&gt; 需要注意的地方： 和之前的示例相比，数据绑定的Mode由OneWay变为了TwoWay (3）在MainPage.cs文件中添加代码12345678910111213141516171819202122232425262728293031323334353637//MainPage.csnamespace TwoWayDataBinding&#123; public sealed partial class MainPage : Page &#123; //用于数据绑定的对象存放在ObservableCollection集合中 public ObservableCollection&lt;Item&gt; Array = new ObservableCollection&lt;Item&gt;(); public MainPage() &#123; Array.Add(new Item("This is the head line, with the pictur 0.png(checked)", "Assets/0.png", true)); Array.Add(new Item("This is the first line, with the pictur 1.png(checked)", "Assets/1.png", true)); Array.Add(new Item("This is the second line, with the pictur 2.png(unchecked)", "Assets/2.png", false)); Array.Add(new Item("This is the third line, with the pictur 3.png(unchecked)", "Assets/3.png", false)); Array.Add(new Item("This is the fourth line, with the pictur 4.png(checked)", "Assets/4.png", true)); this.InitializeComponent(); &#125; //点击添加按钮，将往Array中添加元素，此时我们可以看到ListView实时更新 private void AddButton_Click(object sender, RoutedEventArgs e) &#123; Array.Add(new Item("This is the line you add, with the pictur add.png(unchecked)", "Assets/add.jpg", false)); &#125; /* * 当ListView内的内容发生更改时，点击ShowButton，将触发该事件 * 打印出Array的内容，此时我们可以看到Array的内容随着ListView的变化而变化 */ private void ShowButton_Click(object sender, RoutedEventArgs e) &#123; foreach (var item in Array) &#123; Debug.WriteLine(item.Content + " " + item.Ischecked); &#125; &#125; &#125;&#125; 需要注意的地方： 定义了两个按钮点击相应事件，主要是为了更好地观察到双向绑定的结果 总结整个过程就是这样，其中最重要的地方其实就是Item显示实现接口INotifyPropertyChanged，如果需要转换器的话根据目标类型构造转换器； 其实还有一种方法就是使用MvvmLight的ObservableObject，该类已经实现了这个接口，通过继承这个类既可以实现通知界面更新的功能；具体可见另一篇博客UWP—MvvmLight FYI项目下载：TwoWayDataBinding 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——DataBinding（二）：数据绑定+转换器]]></title>
    <url>%2F%2Fuwp%2FDataBindingWithConverter%2F</url>
    <content type="text"><![CDATA[功能简介在数据绑定的时候，我们有时候会遇到不能直接绑定的情况，如Checkbox的IsChecked属性不能直接绑定一个布尔值，Image的Source属性不能直接绑定到一个string上，这时候就需要添加转换器完成数据绑定 示例项目将编写两个转换器，使Checkbox的IsChecked属性通过转换器绑定一个布尔值上，Image的Source属性通过转换器绑定到一个string上； 示例项目将使用到部分文件存储和双向绑定的内容，但这只是为了演示转换器的功能，本文的重点在于CheckBoxConverter类和ImageConverter的实现，如果想要了解文件存储和双向绑定的内容，可以参考另一篇博客：UWP文件管理和UWP数据绑定——双向绑定 实现效果 启动程序时：Item的属性值通过转换器给Image和Checkbox赋值 点击按钮更改图片，Item的Source属性变化，Image的Source属性值实时更新 实现过程(1）添加一个类CheckBoxConverter该类将继承接口IValueConverter，同时实现接口的两个函数 12345678910111213/** value为需要转化的值* targetType为要转化成的值的类型* parameter为转化时传递的参数，* 根据value的值，返回一个targetType类型的值*/public object Convert(object value, Type targetType, object parameter, string language)&#123; ......&#125;public object ConvertBack(object value, Type targetType, object parameter, string language)&#123; ......&#125; 示例代码中的CheckBoxConverter的功能是将布尔值转化为Checkbox的IsChecked属性值，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//CheckBoxConverter.csnamespace DataBindingWithConverter&#123; /* * 转化器，将布尔值转化为Checkbox的IsChecked属性(System.Nullable`1[System.Boolean]) */ public class CheckBoxConverter : IValueConverter &#123; /* * value为Item的Ischecked 属性，布尔值 * targetType为Checkbox的Ischecked 属性的类型 * parameter为转化时传递的参数，这里为空 */ public object Convert(object value, Type targetType, object parameter, string language) &#123; /* * bool? 表示isChecked可以取null * value as bool? 将value转化为布尔值然后返回，如果不能转化，则返回null */ bool? isChecked = value as bool?; /* * 实际上这里返回的并不是targetType类型的值，而是布尔值 * 但是在代码中返回值为Object，布尔值将被强制转化 * 注意：在类型不能强制转化的情况下，应该根据targetType的类型返回返回需要的值 */ if (isChecked == null || isChecked == false) &#123; return false; &#125; else &#123; return true; &#125; &#125; /* * 因为是单向绑定，所有并不需要编写ConvertBack函数 * 如果使用了双向绑定，可以参考上面函数的写法添加ConvertBack函数的代码 */ public object ConvertBack(object value, Type targetType, object parameter, string language) &#123; throw new NotImplementedException(); &#125; &#125;&#125; 需要注意的地方： 继承接口IValueConverter 根据value和targetType定义Convert函数 (2)同理添加一个类ImageConverter1234567891011121314151617181920//ImageConverter.csnamespace DataBindingWithConverter&#123; class ImageConverter : IValueConverter &#123; //string转ImageSource（Image的Source属性） public object Convert(object value, Type targetType, object parameter, string language) &#123; string source = value as string; ImageSource imageSource = new BitmapImage(new Uri(source)); return imageSource; &#125; //Mode = Oneway，所以不用管ConvertBack的内容 public object ConvertBack(object value, Type targetType, object parameter, string language) &#123; throw new NotImplementedException(); &#125; &#125;&#125; (3) 新建类Item.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//Item.csnamespace DataBindingWithConverter&#123; /* * Item是我们自定义的一个类型，包含三个属性，对应三个控件的属性 * Source --&gt; Image的Source * Ischecked --&gt; Checkbox的checked * 这里继承了接口INotifyPropertyChanged，当Item某一属性值发生更改时，发出通知 * 导致控件的属性也实时更改 * 这里主要是为了测试转化器才这么使用的，可以暂时不用管INotifyPropertyChanged的作用 */ public class Item : INotifyPropertyChanged &#123; private string _source; private bool _ischecked; public string Source &#123; get =&gt; _source; set &#123; _source = value; OnPropertyChanged("Source"); &#125; &#125; public bool Ischecked &#123; get =&gt; _ischecked; set &#123; _ischecked = value; OnPropertyChanged("Ischecked"); &#125; &#125; public Item(string source,bool ischecked) &#123; this._source = source; this._ischecked = ischecked; &#125; //显示实现接口，实现数据绑定动态更新 public event PropertyChangedEventHandler PropertyChanged; protected void OnPropertyChanged(string propertyName = "") &#123; PropertyChangedEventHandler handler = this.PropertyChanged; if (handler != null) &#123; handler(this, new PropertyChangedEventArgs(propertyName)); &#125; &#125; &#125;&#125; (4) 在MainPage.xaml.cs中添加代码123456789101112131415161718192021222324252627282930//MainPage.xaml.csnamespace DataBindingWithConverter&#123; public sealed partial class MainPage : Page &#123; public Item MyItem; //LocalFolder文件存储 private string prefix = "ms-appdata:///local/"; public MainPage() &#123; MyItem = new Item("ms-appx:///Assets/flash.jpg", true); this.InitializeComponent(); &#125; private async void ChangeImage(object sender, RoutedEventArgs e) &#123; var openPicker = new Windows.Storage.Pickers.FileOpenPicker(); openPicker.FileTypeFilter.Add(".jpg"); StorageFile file = await openPicker.PickSingleFileAsync(); //LocalFolder文件存储 Windows.Storage.StorageFolder localFolder = Windows.Storage.ApplicationData.Current.LocalFolder; StorageFile fileCopy = await file.CopyAsync(localFolder, file.Name, NameCollisionOption.ReplaceExisting); //设置MyItem的Source，此时将使用转化器转化为Image的Source值 MyItem.Source = prefix + file.Name; &#125; &#125;&#125; 需要注意的地方： 选择图片后需要把图片保存在LocalFolder，这里主要是因为权限问题 将MyItem的Source值实时更新为新的地址值 (5）在MainPage.xaml中添加代码首先，需要在Grid的上面添加代码： 12345678&lt;!-- 将CheckboxConverter类添加到资源，因为CheckboxConverter和MainPage的命名空间一样，所有使用local x:key可以设置为任何你喜欢的值，下面将通过这个值指向CheckboxConverter--&gt;&lt;Page.Resources&gt; &lt;local:CheckBoxConverter x:Key="ConvertCheck"&gt;&lt;/local:CheckBoxConverter&gt; &lt;local:ImageConverter x:Key="ConvertImage"&gt;&lt;/local:ImageConverter&gt;&lt;/Page.Resources&gt; 然后在Grid中添加控件并绑定，代码如下： 1234567&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;StackPanel&gt; &lt;Image Source="&#123;x:Bind MyItem.Source,Converter=&#123;StaticResource ConvertImage&#125;,Mode=OneWay&#125;" &gt;&lt;/Image&gt; &lt;CheckBox IsChecked="&#123;x:Bind MyItem.Ischecked,Converter=&#123;StaticResource ConvertCheck&#125;,Mode=OneWay&#125;" Content="Whether the CheckBox is checked is depend on the Item."&gt;&lt;/CheckBox&gt; &lt;Button Content="ChangePicture" Click="ChangeImage" Width="300"&gt;&lt;/Button&gt; &lt;/StackPanel&gt;&lt;/Grid&gt; 需要注意的地方： 一开始资源文件的声明 CheckBox的IsChecked属性的绑定，Image的Source属性的绑定 总结总的说来，转化器 + 数据绑定的大致过程就是： 根据需要转化的值和目标类型编写转化器 在xaml.cs中声明资源文件 绑定属性是添加转化器 其实，选择图片后还可以按下面的设置更新Image控件： 123456789101112131415var openPicker = new Windows.Storage.Pickers.FileOpenPicker();openPicker.FileTypeFilter.Add(".jpg");file = await openPicker.PickSingleFileAsync();//将图片赋给右侧的Imageif (file != null)&#123; BitmapImage bitmap = new BitmapImage(); using (var stream = await file.OpenAsync(Windows.Storage.FileAccessMode.Read)) &#123; bitmap.SetSource(stream); &#125; //这里的MyImage为Image的x:Name值 MyImage.Source = bitmap;&#125; 但是为什么不这么做呢？主要是因为两点，一，本文主要是为了演示如何使用转换器，所以更新Item.Source的值然后再使用转换器更新Image；二，在之后使用了MvvmLight之后，你会发现将视图和功能分离的重要性ヽﾐ ´∀｀ﾐノ＜ Tips可能你和我一样不知道Convert和ConvertBack的目标类型是什么，总是搞混，这时候其实我们可以通过Debug.WriteLine()方法打印出目标类型 12using System.Diagnostics;Debug.WriteLine(targetType); FYI项目下载：DataBindingWithConverter 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——DataBinding（一）：简单数据绑定]]></title>
    <url>%2F%2Fuwp%2FSimpleDataBinding%2F</url>
    <content type="text"><![CDATA[功能简介UWP提供了功能强大的数据绑定，假设你有一个集合，数据绑定可以将集合中的数据绑定到xaml的控件上，而且通过模板，你可以只书写一次DataTemplate（数据模板），程序就会自动为你生成多个控件。 示例项目将使用ListView和 ObservableCollection，通过编写DataTemplate，即可实现将集合内的数据自动绑定到ListView中。 实现效果 实现过程(1）添加自定义类Item.cs1234567891011121314151617181920namespace SimpleDataBinding&#123; /* * Item是我们自定义的一个类型，其包含两个属性：content和source（内容和图片地址） */ public class Item &#123; private string _content; private string _source; //封装 public string Content &#123; get =&gt; _content; &#125; public string Source &#123; get =&gt; _source; &#125; public Item(string content, string source) &#123; this._content = content; this._source = source; &#125; &#125;&#125; (2) 在MainPage.xam中添加控件12345678910111213141516171819202122&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;!-- ItemSource用于指定ListView的数据源，这里的Array为MainPage.xml.cs中MainPage类的一个集合 ItemsSource="&#123;x:Bind Array&#125;"将指定ListView的数据源指向MainPage对象的属性Array 该属性为ObservableCollection&lt;Item&gt; --&gt; &lt;ListView Margin="20,20,50,20" ItemsSource="&#123;x:Bind Array&#125;"&gt; &lt;ListView.ItemTemplate&gt; &lt;!-- DataType指定Array中对象的类型，这里的Item为我们自定义的一个类 --&gt; &lt;DataTemplate x:DataType="local:Item"&gt; &lt;RelativePanel&gt; &lt;CheckBox HorizontalAlignment="Left" VerticalAlignment="Top" Margin="10,10,0,0"&gt;&lt;/CheckBox&gt; &lt;Grid Width="90" x:Name="Space"&gt;&lt;/Grid&gt; &lt;!-- Source="&#123;x:Bind Source&#125;"指定Image图片控件的图片源 --&gt; &lt;Image Source="&#123;x:Bind Source&#125;" HorizontalAlignment="Left" Height="40" Margin="50,10,0,0" VerticalAlignment="Top" Width="40"&gt;&lt;/Image&gt; &lt;!-- Text="&#123;x:Bind Content&#125;"指定文本块的内容，Source和Content都是Item的属性 --&gt; &lt;TextBlock Text="&#123;x:Bind Content&#125;" RelativePanel.RightOf="Space" VerticalAlignment="Top" HorizontalAlignment="Left" FontSize="20" Margin="10,12,0,0"&gt;&lt;/TextBlock&gt; &lt;/RelativePanel&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt;&lt;/Grid&gt; 需要注意的地方： 设置ListView的ItemSource 设置DataTemplate的x:DataType 为你想要添加的控件属性设置绑定，如Image控件的Source=”{x:Bind Source}” (3）在MainPage.xaml.cs中添加代码1234567891011121314151617public sealed partial class MainPage : Page &#123; //ObservableCollection表示一个动态数据集合，它可在添加、删除项目或刷新整个列表时提供通知 //用于数据绑定的对象一般存放在ObservableCollection集合中 public ObservableCollection&lt;Item&gt; Array = new ObservableCollection&lt;Item&gt;(); public MainPage() &#123; //往集合中添加对象 Array.Add(new Item("This is the head line, with the pictur 0.png in Folder /Assets.", "Assets/0.png")); Array.Add(new Item("This is the first line, with the pictur 1.png in Folder /Assets.", "Assets/1.png")); Array.Add(new Item("This is the second line, with the pictur 2.png in Folder /Assets.", "Assets/2.png")); Array.Add(new Item("This is the third line, with the pictur 3.png in Folder /Assets.", "Assets/3.png")); Array.Add(new Item("This is the fourth line, with the pictur 4.png in Folder /Assets.", "Assets/4.png")); this.InitializeComponent(); &#125; &#125; 需要注意的地方： 声明ObservableCollection 在构造函数中往ObservableCollection中添加元素 FYI项目下载：SimpleDataBinding 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——标题栏后退按钮的实现和页面缓存]]></title>
    <url>%2F%2Fuwp%2FBackRequested%2F</url>
    <content type="text"><![CDATA[功能简介示例项目有两个页面，MainPage和NewPage，实现从MainPage跳转到NewPage，再从NewPage后退到MainPage，同时还原Mainpage之前的状态； MainPage.xaml代码如下： 123456789101112&lt;!-- MainPage.xaml --&gt;&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;StackPanel&gt; &lt;!-- 一个文本块，一个文本框（可以在其中输入数据，跳转回来后文本框的内容依然存在） 按钮，点击跳转 --&gt; &lt;TextBlock Text="This is the MainPage" Margin="5" FontSize="40"&gt;&lt;/TextBlock&gt; &lt;TextBox Margin="5"&gt;&lt;/TextBox&gt; &lt;Button Content="Navigate To NewPage" Click="NavigateToNewPage" Margin="5"&gt;&lt;/Button&gt; &lt;/StackPanel&gt;&lt;/Grid&gt; NewPage.xaml的代码如下： 12345&lt;!-- NewPage.xaml --&gt;&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt;、 &lt;!-- 就一行，告诉你页面跳转了 --&gt; &lt;TextBlock Text="This is the NewPage" FontSize="40"&gt;&lt;/TextBlock&gt;&lt;/Grid&gt; 实现效果 跳转前—MainPage：在文本框内随意输入内容 跳转后—NewPage：标题栏多了后退按钮 后退—MainPage：之前文本框内的内容被保留了下来 实现过程(1）新建MainPage和NewPage两个页面，并且将上面的xaml代码复制到这两个页面的代码中关于新建一个页面的方法： 解决方案资源管理器—&gt;添加—&gt;新建项—&gt;Visual C#—&gt;空白页 (2) 修改App.xaml.cs 在 OnLaunched方法中添加下面的代码 123456789/** 这里用到了事件的C#事件订阅* SystemNavigationManager.GetForCurrentView().BackRequested将在后退导航的时候发生，* 而 += 符号右边的BackRequested是我们自定义的函数，将在下面声明定义* += 符号是该自定义函数在后退导航的时候，会被调用；* 同理，OnNavigated将在跳转到想要的页面的时候调用*/SystemNavigationManager.GetForCurrentView().BackRequested += BackRequested;rootFrame.Navigated += OnNavigated; 在App.xaml.cs中定义函数：BackRequested 123456789101112//后退按钮点击事件private void BackRequested(object sender, BackRequestedEventArgs e)&#123; Frame rootFrame = Window.Current.Content as Frame; //CanGoBack也是系统内置的一个函数 if (rootFrame != null &amp;&amp; rootFrame.CanGoBack) &#123; SystemNavigationManager.GetForCurrentView().AppViewBackButtonVisibility = AppViewBackButtonVisibility.Collapsed; rootFrame.GoBack(); &#125;&#125; 在App.xaml.cs中定义函数：OnNavigated 1234567//跳转到你想要的页面时发生private void OnNavigated(object sender, NavigationEventArgs e)&#123; //AppViewBackButtonVisibility为标题栏后退按钮是否可见 SystemNavigationManager.GetForCurrentView().AppViewBackButtonVisibility = ((Frame)sender).CanGoBack ? AppViewBackButtonVisibility.Visible : AppViewBackButtonVisibility.Collapsed;&#125; (3）在MainPage.xaml.cs的构造函数上添加代码1this.NavigationCacheMode = Windows.UI.Xaml.Navigation.NavigationCacheMode.Enabled; 这行代码将开启页面缓存，如果需要频繁切换页面，而且页面信息不必实时更新时，使用页面缓存是非常高效的； FYI项目下载：BackRequestedSample 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——自适应界面Adaptive UI(二)]]></title>
    <url>%2F%2Fuwp%2FAdaptiveUI%2F2%2F</url>
    <content type="text"><![CDATA[功能简介 当你看这篇博客的时候，我就假设你已经看过了第一篇博客或者对UWP的自适应界面已经有了一定的了解了；UWP的自适应界面很强大，但是，UWP的自适应界面存在这样的限制，那就是如果你要设置一个控件自适应变换，你就必须给它声明x:Name； 如果我们使用ListView的数据绑定（PS：如果不了解数据绑定，请跳转），那么对于ListView.ItemTemplate里的控件，我们就不能通过声明x:Name绑定到Target上，如下面代码所示 1234567891011121314151617181920212223&lt;!-- MainPage.xaml --&gt;&lt;!-- ItemSource用于指定ListView的数据源，这里的Array为MainPage.xml.cs中MainPage类的一个集合 --&gt;&lt;ListView Margin="20,20,50,20" ItemsSource="&#123;x:Bind Array&#125;" x:Name="MyList"&gt; &lt;ListView.ItemTemplate&gt; &lt;!-- DataType指定Array中对象的类型，这里的Item为我们自定义的一个类 --&gt; &lt;DataTemplate x:DataType="local:Item"&gt; &lt;!-- 这里的ListView对应的模板为一个Checkbox，一个Grid（用于分隔开CheckBox和TextBlock） 一个Imag，还有一个文本框 --&gt; &lt;RelativePanel&gt; &lt;CheckBox HorizontalAlignment="Left" VerticalAlignment="Top" FontSize="14" CharacterSpacing="0" Margin="10,10,0,0"&gt;&lt;/CheckBox&gt; &lt;!-- 在宽屏状态下，Space的宽度为90，这时候文本框和Checkbox中间存在的空间正好存放图片 在窄屏状态下，Space的宽度为0，此时图片隐藏，Checkbox后紧跟着文本框 --&gt; &lt;Grid Width="90" x:Name="Space"&gt;&lt;/Grid&gt; &lt;Image HorizontalAlignment="Left" Height="40" Margin="50,10,0,0" VerticalAlignment="Top" Width="40" Source="&#123;x:Bind Source&#125;" x:Name="MyImage"&gt;&lt;/Image&gt; &lt;TextBlock Text="&#123;x:Bind Content&#125;" RelativePanel.RightOf="Space" VerticalAlignment="Top" HorizontalAlignment="Left" FontSize="20" Margin="10,12,0,0"&gt;&lt;/TextBlock&gt; &lt;/RelativePanel&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt;&lt;/ListView&gt; 如果我们想要在窗口较大的时候显示图片， 而窗口变小的时候隐藏图片，按照之前的方法，我们会发现，即使是在Setter中声明了MyImage.Visibility的Value为Collapsed，图片也不会隐藏 所以这篇博客就是探讨在这种情况下如何实现图片的自适应变化 实现效果 宽屏状态下： 窄屏状态下： 实现过程(1）在MainPage.xml中创建需要的控件这里添加的代码就是上面xaml代码，将上述代码添加到 MainPage.xaml里 (2) 添加一个新的类Item位置：解决方案资源管理器—&gt;添加—&gt;新建项—&gt;Visual C#—&gt;代码—&gt;类 在新建的Item.cs文件中添加下面的代码： 12345678910111213141516171819//Item.cs//AdaptiveUIWithListView为你自己所使用的命名空间，namespace AdaptiveUIWithListView&#123; public class Item &#123; private string _content; private string _source; //封装 public string Content &#123; get =&gt; _content; &#125; public string Source &#123; get =&gt; _source; &#125; //构造函数 public Item(string content, string source) &#123; this._content = content; this._source = source; &#125; &#125;&#125; 需要注意的是，这里的AdaptiveUIWithListView为博客的项目所使用的命名空间，你也可以使用自己定义的命名空间 但是如果你使用了自己定义的命名空间，因为MainPage.xaml.cs和MainPage.xaml里都使用了Item，所以需要添加using指令 假如你的Item使用的命名空间为MyNamespace，那么： 首先需要在MainPage.xaml.cs里添加using MyNamespace; 其次，在xaml前几行的Page属性里添加xmlns:mynamespace=”using:MyNamespace” 和DataTemplate的x:DataType=”local:Item”更改为x:DataType=”mynamespace:Item” （这里的mynamespace可以更改为你自己想要的值） (3）在构造函数上添加函数监听窗口尺寸变化和添加Array这一属性值123456789101112131415161718192021222324252627//MainPage.xaml.cs//ObservableCollection一般用于数据绑定的Sourcpublic ObservableCollection&lt;Item&gt; Array = new ObservableCollection&lt;Item&gt;();public MainPage()&#123; //往Array中添加元素 Array.Add(new Item("This is the head line, with the pictur 0.png in Folder /Assets.", "Assets/0.png")); Array.Add(new Item("This is the first line, with the pictur 1.png in Folder /Assets.", "Assets/1.png")); Array.Add(new Item("This is the second line, with the pictur 2.png in Folder /Assets.", "Assets/2.png")); Array.Add(new Item("This is the third line, with the pictur 3.png in Folder /Assets.", "Assets/3.png")); Array.Add(new Item("This is the fourth line, with the pictur 4.png in Folder /Assets.", "Assets/4.png")); this.InitializeComponent(); //监听窗口大小变化事件 this.SizeChanged += (s, e) =&gt; &#123; if (e.NewSize.Width &gt; 000 &amp;&amp; e.NewSize.Width &lt; 600) &#123; //ShowImage为自定义的函数，见第四步 ShowImage(false); &#125; else &#123; ShowImage(true); &#125; &#125;;&#125; (4）定义ShowImage函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//flag决定图片是否显示private void ShowImage(bool flag)&#123; /* * FindChildren是一个自定义的函数，接受两个参数，一个是List&lt;T&gt;，另一个是窗口的一个控件 * FindChildren运行结束后，将找到该控件的所有子控件中类型为T的控件 * 下面的例子即找到MyList控件中所有类型为RelativePanel的控件 */ List&lt;RelativePanel&gt; list = new List&lt;RelativePanel&gt;(); FindChildren&lt;RelativePanel&gt;(list, MyList); foreach (RelativePanel panel in list) &#123; for (int i = 0; i &lt; panel.Children.Count; i++) &#123; //如果为图片，则判断是否显示 if (panel.Children[i] is Image) &#123; if (flag) &#123; ((Image)panel.Children[i]).Visibility = Visibility.Visible; &#125; else &#123; ((Image)panel.Children[i]).Visibility = Visibility.Collapsed; &#125; &#125; //这里的Grid即xaml中的Space if (panel.Children[i] is Grid) &#123; if (flag) &#123; ((Grid)panel.Children[i]).Width = 90; &#125; else &#123; ((Grid)panel.Children[i]).Width = 40; &#125; &#125; &#125; &#125;&#125;//遍历startNode的子节点，找到类型为T的控件并且放在results中internal static void FindChildren&lt;T&gt;(List&lt;T&gt; results, DependencyObject startNode) where T : DependencyObject &#123; int count = VisualTreeHelper.GetChildrenCount(startNode); for (int i = 0; i &lt; count; i++) &#123; DependencyObject current = VisualTreeHelper.GetChild(startNode, i); if ((current.GetType()).Equals(typeof(T)) || (current.GetType().GetTypeInfo().IsSubclassOf(typeof(T)))) &#123; T asType = (T)current; results.Add(asType); &#125; FindChildren&lt;T&gt;(results, current); &#125; &#125; 总结最后总结一下，整个图片隐藏的过程就是： FYI 其实，之前我还尝试过另一种方法，就是添加自定义控件UserControl的方法，然后在UserControl里设置VisualStateManager的Setter，然后再ListView里RelativePanel替换为 123&lt;UserControl&gt; ......&lt;/UserControl&gt; 这样确实能实现图片的自动隐藏，但是却有出现另一个问题：Item的传值问题 如果使用UserControl，那么Item的属性值就必须传递给UserControl，在Debug模式下，我观察到Item的属性值确确实实已经传递给UserControl，但是UserControl的控件却没有显示出来，所以我想可能是UserControl先渲染出控件，然后才接收Item传递过来的值 如果有好的解决方法，欢迎在下面评论或者邮件（侧边栏点开就能找到了）ᕕ( ՞ ᗜ ՞ )ᕗ 项目下载：AdaptiveUIWithListView 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥) op1=>operation: SizeChanged函数监听窗口变化 op2=>operation: 设置flag的值 op3=>operation: showImage接收flag op4=>operation: Findchildren找到所有的RelativePanel op5=>operation: 根据flag设置RelativePanel里的图片是否隐藏 op1->op2->op3->op4->op5{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——自适应界面Adaptive UI(一)]]></title>
    <url>%2F%2Fuwp%2FAdaptiveUI%2F</url>
    <content type="text"><![CDATA[功能简介UWP 自适应界面，布局面板依据可用的屏幕空间，指定界面元素的大小和位置，设置相应控件的属性； 示例项目的实现的功能： 当窗口大小大于600时，同时并排显示两张图片 当窗口大小小于600时，只显示一张图片 实现效果 宽屏状态下： 窄屏状态下： 实现过程（1）在MainPage.xml中创建需要的控件123456789&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;!-- 创建了两个Image控件，放在Grid的第一列和第二列 --&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width="*"&gt;&lt;/ColumnDefinition&gt; &lt;ColumnDefinition Width="*" x:Name="RightColumn"&gt;&lt;/ColumnDefinition&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Image Grid.Column="0" Source="Assets/left.jpg" &gt;&lt;/Image&gt; &lt;Image Grid.Column="1" Source="Assets/right.jpg"&gt;&lt;/Image&gt;&lt;/Grid&gt; (2) 使用VisualStateManager在你要添加自适应的Grid添加下面这段代码，这里主要是设置了不同的VisualState，直译就是可视状态，不同的可视状态可以在Setter中设置自己想要的值 1234567891011121314151617181920&lt;VisualStateManager.VisualStateGroups&gt; &lt;VisualStateGroup x:Name="LayoutVisualStates"&gt; &lt;!-- 这里设置了两个VisualState：WideLayout和NarrowLayout,x:Name是你自己取得名字 --&gt; &lt;VisualState x:Name="WideLayout"&gt; &lt;VisualState.Setters&gt; &lt;!-- 这里实际上可以包括多个setter，Target为对应控件的属性，Value为你想要设置的属性值 当处于WideLayout状态下时，RightColumn（对应是哪个控件见上面）的宽度被设置为* --&gt; &lt;Setter Target="RightColumn.Width" Value="*"&gt;&lt;/Setter&gt; &lt;/VisualState.Setters&gt; &lt;/VisualState&gt; &lt;VisualState x:Name="NarrowLayout"&gt; &lt;!-- 这里也是同样的道理 --&gt; &lt;VisualState.Setters&gt; &lt;Setter Target="RightColumn.Width" Value="0"&gt;&lt;/Setter&gt; &lt;/VisualState.Setters&gt; &lt;/VisualState&gt; &lt;/VisualStateGroup&gt;&lt;/VisualStateManager.VisualStateGroups&gt; （3）在构造函数上添加函数监听窗口尺寸变化1234567891011121314151617181920public MainPage()&#123; this.InitializeComponent(); /* * C#事件订阅 * Lambda表达式，s和e为传入参数 */ this.SizeChanged += (s, e) =&gt; &#123; //首先，state默认设置为WideLayout（WideLayout是你在xaml里设置的名字） var state = "WideLayout"; if (e.NewSize.Width &gt; 000 &amp;&amp; e.NewSize.Width &lt; 600) &#123; //如果界面小于600，则将state设置为NarrowLayout state = "NarrowLayout"; &#125; //这里将变换State VisualStateManager.GoToState(this, state, true); &#125;;&#125; 补充关于&lt;Grid.ColumnDefinitions&gt;和&lt;Grid.RowDefinitions&gt; Grid.ColumnDefinitions 和 Grid.RowDefinition 会将整个Grid控件划分行和分列，如上边的例子将会把Grid分为两列 那么ColumnDefinitions里的Width属性表示什么呢？Width表示该列的宽度，有三种取值： Auto：该控件有多宽，呈现出来就有多宽，比如说如果该列的内容是一张图片，那么按原图片的宽度显示出来 具体数值，如400：即直接指定控件的宽度（不推荐直接指定控件的宽度，因为UWP应用是跨平台的，如果指定宽度的话，在一台电脑里也许这个宽度看起来挺好的，换成windowPhone就。。。） “*“或一个整数/小数紧跟着一个星号，表示的是整个Grid控件的宽度减去属性为Auto和具体数值的控件的宽度，剩下的宽度按比例分给这些带星号的控件，数值越大分的越多 下面是一个具体的例子： 12345678910111213141516171819&lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height="*" /&gt; &lt;RowDefinition Height="20" /&gt; &lt;RowDefinition Height="*" /&gt;&lt;/Grid.RowDefinitions&gt;&lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width="*" /&gt; &lt;ColumnDefinition Width="30" /&gt; &lt;ColumnDefinition Width="*" /&gt;&lt;/Grid.ColumnDefinitions&gt;&lt;Grid Grid.Row="0" Grid.Column="0" BorderBrush="AliceBlue" BorderThickness="3"&gt;&lt;/Grid&gt;&lt;Grid Grid.Row="0" Grid.Column="1" BorderBrush="AliceBlue" BorderThickness="3"&gt;&lt;/Grid&gt;&lt;Grid Grid.Row="0" Grid.Column="2" BorderBrush="AliceBlue" BorderThickness="3"&gt;&lt;/Grid&gt;&lt;Grid Grid.Row="1" Grid.Column="0" BorderBrush="AliceBlue" BorderThickness="3"&gt;&lt;/Grid&gt;&lt;Grid Grid.Row="1" Grid.Column="1" BorderBrush="AliceBlue" BorderThickness="3"&gt;&lt;/Grid&gt;&lt;Grid Grid.Row="1" Grid.Column="2" BorderBrush="AliceBlue" BorderThickness="3"&gt;&lt;/Grid&gt;&lt;Grid Grid.Row="2" Grid.Column="0" BorderBrush="AliceBlue" BorderThickness="3"&gt;&lt;/Grid&gt;&lt;Grid Grid.Row="2" Grid.Column="1" BorderBrush="AliceBlue" BorderThickness="3"&gt;&lt;/Grid&gt;&lt;Grid Grid.Row="2" Grid.Column="2" BorderBrush="AliceBlue" BorderThickness="3"&gt;&lt;/Grid&gt; 效果截图： 总结整个自适应界面的实现过程大致就是这样了，其实这其中最重要的部分就是第二部分，VisualStateManager中Setter的设置，除了文中提到的Width设置，你还可以根据自己的需要设置不同的值，反正可以在Xaml文件中设置的控件的属性值都利用Setter设置 FYI项目下载：AdaptiveUISample 友链：C# 事件订阅 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
</search>
