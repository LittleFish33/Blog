<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据库：存放变长记录的Page类代码实现]]></title>
    <url>%2FDataBase%2FSimplePage%2F</url>
    <content type="text"><![CDATA[设计思路文章实现的思路大致参考教材Database Management Systems, 3rd Edition by Raghu Ramakrishnan (Author), Johannes Gehrke (Author) 下面内容摘自教材： ​ 对变长记录最灵活的组织方式是为每一页维护一个槽目录，每个槽有 对组成，第一部分(record offset) 是指向记录的“指针“。如下图所示，它表示从页上数据部分的开始处到记录的开始处的字节偏移量。删除操作通过设置记录的偏移量为-1很容易完成。记录能在页内以移动，因为由页号和槽号组成的rid（即目录中的位置）在记录移动时不会发生改变，只有存储在槽中的记录的偏移量改变了。 ​ 因为页没有被预先格式化成槽，所以，为新记录分配空间必须小心管理。管理空间的一种方法是维护一个指向空闲空间开始处的指针（即从数据部分开始处的偏移量）。当一个新记录太大而不能放在剩余的空闲空间时，就不得不在页内移动记录以收回先前已被删除记录释放的空间。其思想是确保重新组织后，所有记录是连续的，后面是可分配的空闲空间。 ​ 值得注意的是，被删除记录所在的槽不能从槽目录中移出，因为槽号用于标识记录，如果删除一个槽，将改变槽目录中后续槽的槽号，以至于导致后续槽所指向的记录的rid的改变。从槽目录中删除槽的唯一方法是当最后一个槽所指向的记录被删除后，可以移出最后一个槽。然而，当插入一个记录时，应该首先扫描槽目录已寻找目前未指向任何目录的槽，并把新记录存于该槽。只有当所有存在的槽都指向记录时，才能向槽目录中增加新的槽。如果插入操作比删除操作更普遍（这是比较典型的情况），槽目录中的目录项数将非常接近页上的实际记录数。 ​ 上述组织方法对于需要频繁移动的定长记录的情况也是很有用的，如需要维护记录的某种排列顺序的情况。事实上，当所有记录长度相同时，可以不再每个记录的槽中存储这些公共长度的信息，而只在系统目录中存储一次。 代码实现Page类的初始化结构​ 在没有插入任何数据项的情况下，页内的数据结构如下图所示，首先，存放的是页的配置信息，然后是指向第一个槽的空间，剩下的空间是空闲空间，之后的记录项将倒着插入这个空间内；槽结构包括槽的长度和对应记录的起始地址 12345678910111213141516171819202122232425262728//Page.hppclass Page&#123;private: //槽 struct Slot_t &#123; Offset offset; /* 如果槽是空的，length的长度为-1 */ Length length; &#125;; /* 页的配置项所占用的空间，总大小 - DPFIXED = 数据的空间 */ static const int DPFIXED = sizeof(Slot_t) + sizeof(SlotNumber) + sizeof(LocationIndex) * 2 + sizeof(PageId) * 3 + sizeof(bool) * 4; SlotNumber slotNumber; /* 页里面的槽的数目 */ LocationIndex pd_lower; /* 空闲空间的起始地址，终止地址 - 起始地址 = 剩余空闲空间的大小 */ LocationIndex pd_upper; /* 空闲空间的终止地址，终止地址 - 起始地址 = 剩余空闲空间的大小 */ PageId prevPage; /* 上一页的页ID */ PageId curPage; /* 当前的页ID */ PageId nextPage; /* 下一页的页ID */ bool full; Slot_t slot[1]; /* 槽数据的第一个地址 */ char data[MAX_SPACE - DPFIXED]; /* 空闲空间 */ //......这里省略了页面的功能函数&#125; 插入记录的一种情况​ 当插入记录的时候，首先检查记录的长度是否超过了空闲空间的大小，如果是的话，将会返回信息——页面已满，反之，如果空闲空间大于记录的长度，那么将会把记录倒着插入空闲空间；由于slot[0]的空间后紧跟着就是空闲空间的起始地址，（这里是C++提供的便利，就不用像上面教材里说的一样使用一个指向空闲空间的指针了，︿(￣︶￣)︿），因此即使我们在构造Page类的时候使Slot目录申请为大小为1的数组，但是我们依然可以使用slot[1]，slot[2]…..指向槽目录下面的空间，因为它们将指向空闲空间，我们只需要插入记录的时候同时移动指向空闲空间的起始位置的指针，那么由于数据项是倒着插入的，那么数据项将不会和槽同时占用一个空间导致内存访问冲突；需要注意的是，槽的数目永远都比记录项多一； 如图： 12345678910111213141516171819202122/* * 文件: Page.cpp * 函数：Status Page::insertRecord(char* recPtr, int recLen) */if (recLen &gt; pd_upper - pd_lower) &#123; //这里省略了插入数据的另外一种情况，将在下面介绍完删除记录后介绍&#125;else &#123; //如果空闲空间足够大，将新数据直接插入空闲空间，同时更新页面属性 pd_upper -= recLen; pd_lower += sizeof(Slot_t); slot[slotNumber].offset = pd_upper; slot[slotNumber].length = recLen; memcpy(data + pd_upper, recPtr, recLen); slotNumber++; int insertKey; memcpy(&amp;insertKey, data + slot[slotNumber-1].offset, 4); //排序 sort_slot(insertKey,recLen,pd_upper); return SUCCESS;&#125; 删除记录删除记录的情况就很简单了，直接将对应槽号的长度设为0，表示该记录失效； 1234567891011121314151617/* * 文件: Page.cpp * 函数：Status Page::deleteRecord(int key) */Status Page::deleteRecord(int key)&#123; int slotNo; if (!isExist(key, slotNo)) &#123; return RECORDNOTFOUND; &#125; //删除记录，直接将slot的长度置为0 slot[slotNo].length = 0; full = false; return SUCCESS; &#125; 插入记录的另一种情况​ 因为删除记录的时候我们只是简单地将对应槽号的长度设置为0，因此即使pd_upper - pd_lower &lt; 记录的长度，但是也存在有的槽记录是无效的情况，那么我们就需要遍历所有的槽，检查是否有槽是无效的，如果有，那么插入记录；反之，返回页已满。 12345678910111213141516171819202122/* * 文件: Page.cpp * 函数：Status Page::insertRecord(char* recPtr, int recLen) */if (recLen &gt; pd_upper - pd_lower) &#123; //如果不存在空闲空间，那么判断是否有槽的数据是没用的 for (size_t i = 0; i &lt; slotNumber; i++) &#123; //如果槽内的记录的长度为0，表示记录无效，将新纪录覆盖该记录 if (slot[i].length == 0) &#123; slot[i].length = recLen; memmove(data + slot[i].offset, recPtr, recLen); int insertKey; memcpy(&amp;insertKey, recPtr, 4); //排序 sort_slot(i,insertKey, recLen, slot[i].offset); return SUCCESS; &#125; &#125; full = true; return PAGEFULL;&#125; 排序​ 我们的页面里存放的是有序的记录，因此对于每次插入的数据，我们需要对页面的内容进行排序，但是，因为记录项很可能比槽的大小大很多，如果频繁地移动记录的话，很可能造成很大的消耗，因此，我们只需要移动槽的内容就可以了，这样通过遍历槽取出数据的时候，就可以保证数据是有序的。 1234567891011121314151617181920212223242526/* * 文件: Page.cpp * 函数：void Page::sort_slot(int insertKey,int length,int offset) */void Page::sort_slot(int insertKey,int length,int offset)&#123; int curKey; //对页面的记录进行排序，排序的过程实际上移动的是槽的值 for (size_t i = 0; i &lt; slotNumber; i++) &#123; if (slot[i].length != 0) &#123; memcpy(&amp;curKey, data + slot[i].offset, 4); if (curKey &gt; insertKey) &#123; for (size_t j = slotNumber - 1; j &gt; i; j--) &#123; slot[j].offset = slot[j - 1].offset; slot[j].length = slot[j - 1].length; &#125; slot[i].length = length; slot[i].offset = offset; return; &#125; &#125; &#125;&#125; 总结整个Page类的实现过程就是这样了，比较有意思的部分是slot的实现方式，其他的只要根据教材的设计思路实现就没什么问题了，啦啦啦 整个Page类代码下载：SimplePage 项目中main.cpp为测试代码，运行效果如下： rel.hpp里可以设置Page的大小，测试代码里是100B]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——应用图标的实现方法]]></title>
    <url>%2Fuwp%2FIcon%2F</url>
    <content type="text"><![CDATA[背景应用程序很多时候需要图标，这里介绍两种常用的方法： 使用Segoe MDL2 Assets 提供的图标库简易实现 使用Microsoft Expression Design自己 绘制 Segoe MDL2 Assets如果使用 C#/VB/C++ 和 XAML 开发应用，可通过 Symbol 枚举使用 Segoe MDL2 Assets 中的指定字形。 1&lt;SymbolIcon Symbol="GlobalNavigationButton"/&gt; 但是Symbol 枚举提供的图标有限，如果想使用 Symbol 枚举中未包含的 Segoe MDL2 Assets 字体的字形，可使用 FontIcon。 1&lt;FontIcon FontFamily="Segoe MDL2 Assets" Glyph="&amp;#xE700;"/&gt; FontIcon 提供的图标还是比较全面的，全部可以使用的图标可以参考官方文档 自己绘制Icon图标有时候，如果没法找到我们想要的图标的时候，这个时候我们就可以考虑自己绘制图标了： 第一步，下载Microsoft Expression Design微软官方有免费版本，足够使用了，直接下载就好，传送门 第二步，绘制自己想要的图标绘制好图标之后，菜单栏选择 File–&gt;Export 右边可以设置对应的导出参数，这个看一下就明白了。 我的导出结果： 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;Canvas xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" x:Name="Untitled1" Width="800" Height="600" Clip="F1 M 0,0L 800,0L 800,600L 0,600L 0,0"&gt; &lt;Canvas x:Name="Layer_1" Width="800" Height="600" Canvas.Left="0" Canvas.Top="0"&gt; &lt;Ellipse x:Name="Ellipse" Width="438" Height="423" Canvas.Left="181.5" Canvas.Top="85.4999" Stretch="Fill" StrokeLineJoin="Round" Stroke="#FF000000" Fill="#FFFFFFFF"/&gt; &lt;Path x:Name="Path" Width="232" Height="267.736" Canvas.Left="324.5" Canvas.Top="174.132" Stretch="Fill" StrokeLineJoin="Round" Stroke="#FF000000" Fill="#FFFFFFFF" Data="F1 M 556,308L 325,174.632L 325,441.368L 556,308 Z "/&gt; &lt;/Canvas&gt;&lt;/Canvas&gt; 然后就可以使用这段代码提供的path绘制我们的图标了，比如说我们使用该图标创建一个按钮： 1234567891011121314&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;" &gt; &lt;Button HorizontalAlignment="Stretch" VerticalAlignment="Center" Padding="0" Width="40" Height="40" Background="Transparent"&gt; &lt;Grid&gt; &lt;Ellipse Fill="Red" Height="35" Width="35" Margin="0" VerticalAlignment="Center" HorizontalAlignment="Center"&gt; &lt;/Ellipse&gt; &lt;!-- 这里的Data就是上面生成的代码里的Data --&gt; &lt;Path Data="F1 M 556,308L 325,174.632L 325,441.368L 556,308 Z" Stretch="Uniform" Fill="White" Width="14" Height="14" Margin="0,0,0,0" RenderTransformOrigin="0.5,0.5"&gt; &lt;Path.RenderTransform&gt; &lt;CompositeTransform TranslateX="1"/&gt; &lt;/Path.RenderTransform&gt; &lt;/Path&gt; &lt;/Grid&gt; &lt;/Button&gt;&lt;/Grid&gt; 效果如下：]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的代码仓库：单例模式]]></title>
    <url>%2FCodeBase%2FSingleton%2F</url>
    <content type="text"><![CDATA[C++ 版内部静态变量的懒汉实现，在instance函数里定义一个静态的实例，也可以保证拥有唯一实例，在返回时只需要返回其指针就可以了。 1234567891011121314151617181920class Singleton&#123;protected: Singleton() &#123; pthread_mutex_init(&amp;mutex); &#125;public: static pthread_mutex_t mutex; static Singleton* initance();&#125;;pthread_mutex_t Singleton::mutex;Singleton* Singleton::initance()&#123; pthread_mutex_lock(&amp;mutex); static Singleton obj; pthread_mutex_unlock(&amp;mutex); return &amp;obj;&#125; C# 版多线程下的单例模式，考虑了线程安全 123456789101112131415161718192021222324public class Singleton&#123; private static Singleton instance; private static object _lock=new object(); private Singleton() &#123; &#125; public static Singleton GetInstance() &#123; if(instance==null) &#123; lock(_lock) &#123; if(instance==null) &#123; instance=new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; Java 版12345678910111213141516public class SingletonDemo &#123; private volatile static SingletonDemo instance; private SingletonDemo()&#123; &#125; public static SingletonDemo getInstance()&#123; if(instance==null)&#123; synchronized (SingletonDemo.class)&#123; if(instance==null)&#123; instance=new SingletonDemo(); &#125; &#125; &#125; return instance; &#125;&#125; FYI单例模式其实有很多种实现形式，这里只是选了个人比较常用的版本，便于自己忘记的时候可以马上使用。]]></content>
      <categories>
        <category>代码仓库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库 Postgresql常用语句]]></title>
    <url>%2FDataBase%2FpostgresqlNote%2F</url>
    <content type="text"><![CDATA[新建数据库：create database testdb; 查看所有的数据库：\l 查看所有的表：\d 切换数据库：\c testdb; 删除数据库：drop database testdb; 创建表： 12345CREATE TABLE table_name( column1 datatype, column2 datatype, column3 datatype, PRIMARY KEY( one or more columns ) ); 删除表：drop table table_name; 创建模式：create schema schema_name; 删除模式：drop schema schema_name; 递归删除模式：drop schema schema_name cascade; 插入数据：INSERT INTO TABLE_NAME (column1, column2, column3,...columnN) VALUES (value1, value2, value3,...valueN); 可以同时插入多个值 查询语句：SELECT ID, NAME, AGE, SALARY FROM EMPLOYEES WHERE [condition]; 更新语句：UPDATE table_name SET column1 = value1, column2 = value2...., columnN = valueN WHERE [condition]; 删除语句：DELETE FROM table_name WHERE [condition]; Order By： 1234SELECT column-listFROM table_name [WHERE condition]ORDER BY column1, column2, .. columnN [ASC | DESC]; 分组： 12345SELECT column-list FROM table_name WHERE [conditions ] GROUP BY column1, column2....columnN [ORDER BY column1, column2....columnN]eg：select name,sum(id) from student group by name; Having： 123456SELECT column-list FROM table_name WHERE [conditions ] GROUP BY column1, column2....columnN Having [ conditions ] [ORDER BY column1, column2....columnN] 查询条件：And、Or、Not、Like、In、Not In、Between Like：以su开头：“%su” 内连接： 123SELECT table1.columns, table2.columns FROM table1 INNER JOIN table2 ON table1.common_filed = table2.common_field; 外连接： 123SELECT table1.columns, table2.columns FROM table1 LEFT OUTER JOIN table2 ON table1.common_filed = table2.common_field; 外连接分为左外连接，右外连接，全外连接 跨连接（叉乘）：SELECT coloums FROM table1 CROSS JOIN table2 创建视图： 123CREATE [TEMP | TEMPORARY] VIEW view_name AS SELECT column1, column2..... FROM table_name WHERE [condition]; 删除视图：DROP VIEW view_name; 函数： 1234567891011121314151617181920212223CREATE [OR REPLACE] FUNCTION function_name (arguments) RETURNS return_datatype AS $variable_name$ DECLARE declaration; [...] BEGIN &lt; function_body &gt; [...] RETURN &#123; variable_name | value &#125; END; LANGUAGE plpgsql;--exampleCREATE OR REPLACE FUNCTION totalRecords () RETURNS integer AS $total$ declare total integer; BEGIN SELECT count(*) into total FROM EMPLOYEES; RETURN total; END; $total$ LANGUAGE plpgsql;--执行创建的函数select totalRecords(); 触发器 12345CREATE TRIGGER trigger_name [BEFORE|AFTER|INSTEAD OF] event_name ON table_name [ -- Trigger logic goes here.... ]; 别名：As 可以列、表添加别名 索引： 单列索引：CREATE INDEX index_name ON table_name (column_name); 多列索引：CREATE INDEX index_name ON table_name (column1_name, column2_name); 唯一索引：CREATE UNIQUE INDEX index_name on table_name (column_name); Union：两个结合的表必须有相同的列，去重 Union all：两个结合的表必须有相同的列，不去重 Alter 12345678910111213141516171819202122232425262728293031使用ALTER TABLE语句在现有表中添加新列的基本语法如下：ALTER TABLE table_name ADD column_name datatype;现有表中ALTER TABLE到DROP COLUMN(删除某个字段)的基本语法如下：ALTER TABLE table_name DROP COLUMN column_name;ALTER TABLE更改表中列的DATA TYPE(修改字段类型)的基本语法如下：ALTER TABLE table_name ALTER COLUMN column_name TYPE datatype;ALTER TABLE向表中的列添加NOT NULL约束的基本语法如下：ALTER TABLE table_name MODIFY column_name datatype NOT NULL;ALTER TABLE添加唯一约束ADD UNIQUE CONSTRAINT到表中的基本语法如下：ALTER TABLE table_nameADD CONSTRAINT MyUniqueConstraint UNIQUE(column1, column2...);ALTER TABLE将“检查约束”添加到表中的基本语法如下所示：ALTER TABLE table_nameADD CONSTRAINT MyUniqueConstraint CHECK (CONDITION);ALTER TABLE添加主键ADD PRIMARY KEY约束的基本语法如下：ALTER TABLE table_nameADD CONSTRAINT MyPrimaryKey PRIMARY KEY (column1, column2...);使用ALTER TABLE从表中删除约束(DROP CONSTRAINT)的基本语法如下：ALTER TABLE table_nameDROP CONSTRAINT MyUniqueConstraint;使用ALTER TABLE从表中删除主键约束(DROP PRIMARY KEY)约束的基本语法如下：ALTER TABLE table_nameDROP CONSTRAINT MyPrimaryKey; 截断表：TRUNCATE TABLE table_name; 事务： 锁：LOCK [ TABLE ]name IN lock_mode; lock_mode包括：ACCESS SHARE，ROW SHARE，ROW EXCLUSIVE，SHARE UPDATE EXCLUSIVE，SHARE，SHARE ROW EXCLUSIVE，EXCLUSIVE，ACCESS EXCLUSIVE（未指定的情况下选择最严格的模式）。 自动递增：serial 123CREATE TABLE tablename ( colname SERIAL); 权限： 123456789--GrantGRANT privilege [, ...]ON object [, ...]TO &#123; PUBLIC | GROUP group | username &#125;--RevokeREVOKE privilege [, ...]ON object [, ...]FROM &#123; PUBLIC | GROUP groupname | username &#125; 文章参考教程]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——蜜汁bug]]></title>
    <url>%2Fuwp%2FUWPBug%2F</url>
    <content type="text"><![CDATA[一个蜜汁bug，运行的时候将会在下面的代码位置报错，主要原因是页面渲染出错，这个时候一般就要去看你的xaml代码了，这个东西也没法定位报错的位置，还是比较麻烦的 …(｡•ˇ‸ˇ•｡)… 12345678910111213141516171819public void InitializeComponent()&#123; if (_contentLoaded) return; _contentLoaded = true; #if DEBUG &amp;&amp; !DISABLE_XAML_GENERATED_BINDING_DEBUG_OUTPUT DebugSettings.BindingFailed += (sender, args) =&gt; &#123; global::System.Diagnostics.Debug.WriteLine(args.Message); &#125;; #endif #if DEBUG &amp;&amp; !DISABLE_XAML_GENERATED_BREAK_ON_UNHANDLED_EXCEPTION UnhandledException += (sender, e) =&gt; &#123; if (global::System.Diagnostics.Debugger.IsAttached) global::System.Diagnostics.Debugger.Break(); &#125;; #endif&#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理与接口设计——期中课程设计：使用X86编程语言实现的迷宫游戏]]></title>
    <url>%2FCOD%2FMazeGame%2F</url>
    <content type="text"><![CDATA[功能简介与实现效果一个用X86实现的迷宫游戏，首先，在进入游戏首页之后，玩家可以根据自己的喜好选择自己想要玩的难度，本游戏总共有是三个难度，Easy，Normal，Hard，分别对应三个不同难度的迷宫； 在选择了迷宫难度之后，将会刷新出一个对应难度的迷宫，在这个游戏中，玩家扮演的是一个想要逃离迷宫的小人，这个人用一个笑脸表示，只有当玩家控制角色到达迷宫的出口，即迷宫中标有 A 的位置时候，才能获得游戏的胜利；玩家将通过键盘上的W,A,S,D 键对角色进行移动，分别对应向上，左，下，右移动；当碰到障碍物的时候，角色将不能往那个方向移动； 在成功走出迷宫之后，玩家可以选择进入下一关或者是离开游戏；如果玩家已经走出最难的迷宫，那么玩家也可以选择继续游戏，重新玩一遍游戏； 程序流程图 实现过程第一步，我们需要在DATA SEGMENT 中存放一些我们之后要使用的数据 首先，是将整个迷宫模型保存在MSG_EASYMAZE（简单难度），MSG_NORMALMAZE（普通难度），MSG_HARDMAZE中（困难难度），分别对应三个难度的迷宫模型（这里限于篇幅值显示了MSG_EASYMAZE，另外两个迷宫是一样的原理，具体内容可以下载最下面的源代码查看） 1234567891011MSG_EASYMAZE DB "---------------------------------------------|", 0AH, 0DH DB " | | | | | |", 0AH, 0DH DB "| |------------ |--- | | | | | | | |", 0AH, 0DH DB "| | | | | | | | | |", 0AH, 0DH DB "| |--| ---| |--|-----| |------ | |--| |", 0AH, 0DH DB "| | | | |--| | |", 0AH, 0DH DB "|--- | |-----| | ------| ------|", 0AH, 0DH DB "| | | | |--| | | |", 0AH, 0DH DB "| ------| ------| |--| | |--- |--- | |", 0AH, 0DH DB "| | | | A", 0AH, 0DH DB "|--------------------------------------------|$" 然后，是一些字符串，这些字符串将在游戏引导界面告诉玩家该如何操作: 1234567891011121314151617NEW_LINE DB 13,10,"$"MSG_WON DB "You Have Won!!! $", 0AH, 0DHMSG_NEXTLEVEL DB 13,10,"Go To The Next Level: Enter Y to the Next Level,Input Others to Exit!$",0AH, 0DH MSG_CONTINUE DB 13,10,"If Continue: Enter Y to Continue,Input Others to Exit!$",0AH, 0DH MSG_INSTRUCTION DB "WELCOME !!! $", 0AH, 0DHMSG_SETLEVEL DB "Enter the level you want to play(0 for easy,1 for normal,2 for difficulty): ",0AH, 0DHDB "Any Invalid Input Will Be Treat As 0: $",0AH, 0DHMSG_CONTROL DB "You are about to play the game, remember,you can use the w,a,s,d in the keyboard to move",0AH, 0DHDB "w for up, a for west, s for down, d for east, enter any key to play the game, have a good time!!!$",0AH, 0DH 然后是一些我们需要使用的变量： 变量名 功能 x 玩家当前的x坐标 y 玩家当前的y坐标 NextX 玩家下一步的x坐标 NextY 玩家下一步的y坐标 position 临时变量，用于取出某个位置的内容（用于判断是不是为空，如果为空，则可以移动到该位置） dirInput 临时变量，用于保存输入的移动指令,w,s,a,d difficulty 临时变量，用于保存输入的难度 player 表示玩家（打印该变量即打印玩家） direction 输入的指令（如Y表示Yes，用于判断是否继续游戏等函数） 12345678910x DB 0H ; the x-coordinate of the playery DB 0H ; the y-coordinate of the playerNextX DB 0H ; the next x-coordinate of the playerNextY DB 0H ; the next y-coordinate of the player position DB 0H ; a template variable that we use to contain the character in the positiondirInput DB 0H ; the direction you input that your player will move difficulty DW 0H player DB 01Hdirection DB 0H 之后我们添加进入游戏之前的引导界面代码1234567891011121314151617181920212223242526START: MOV AX, DATA MOV DS, AX MOV ES, AXINSTRUCTION: CALL CLEAN_SCREEN LEA DX, MSG_INSTRUCTION ; print the welcome CALL SHOW LEA DX, NEW_LINE CALL SHOW LEA DX, MSG_CONTROL ; print how to control the player CALL SHOW LEA DX, NEW_LINE CALL SHOW LEA DX, MSG_SETLEVEL ; choose the difficulty CALL SHOW CALL GET_INPUT MOV direction, AL CMP direction,'0' JE GAME_START ; easy game CMP direction,'1' JE GAME_START_NORMAL ; normal game CMP direction,'2' JE GAME_START_HART ; hard game CALL GAME_START ; default : easy game 第三步，选择对应难度之后绘制对应难度的地图，下面以easy game为例： 首先，是绘制迷宫 12345678910111213;start the game GAME_START: CALL EASYMAZE ;draw the maze CALL SET_STARTPOS ;set the start position of the character CALL PRINT_PLAYER JMP ChangePos ; Draw the easy maze EASYMAZE: CALL CLEAN_SCREEN LEA DX, MSG_EASYMAZE CALL SHOW RET 打印出地图之后，我们需要在起始位置：即迷宫的入口打印玩家： 123456789101112131415161718; Set the begin position of the playerSET_STARTPOS: MOV NextX, 0H MOV NextY, 1H MOV x, 0H MOV y, 1H MOV DL, x MOV DH, y MOV BH, 0H MOV AH, 2H INT 10H RET ; Print the player to the console PRINT_PLAYER: MOV DL, player CALL SHOW_CHARACTER RET 第四步，开始监听键盘输入指令，对输入的对应指令进行处理，移动玩家 监听键盘输入：w, a, s, d 123456789101112131415161718192021ChangePos: CALL GET_INPUT ; get the input MOV dirInput, AL ; case : w/W(up),a/A(left),s/S(down),d/D(right) CMP dirInput, 'W' JE MOVE_NORTH CMP dirInput, 'A' JE MOVE_WEST CMP dirInput, 'S' JE MOVE_SOUTH CMP dirInput, 'D' JE MOVE_EAST CMP dirInput, 'w' JE MOVE_NORTH CMP dirInput, 'a' JE MOVE_WEST CMP dirInput, 's' JE MOVE_SOUTH CMP dirInput, 'd' JE MOVE_EAST JMP ChangePos 根据对应的输入控制角色进行相应的移动，我们以输入了W为例，整个移动过程如下 删除原位置的字符 更新下一步的位置 判断下一步的位置是否合法 如果是，移动坐标到该位置，反之，不移动 回到ChangePos继续监听键盘输入，进行下一步移动 12345678910MOVE_NORTH: CALL REMOVE_OLDPOS ;remove the character in previous position DEC NextY CALL ISVALID_POS DEC y ;if the positon is empty, then update the position MOV DL, x MOV DH, y CALL SET_CURSOR CALL PRINT_PLAYER JMP ChangePos ; go back to the ChangePos function, to read the next input 删除原位置的字符 12345678;This function is used to remove the character in previous positionREMOVE_OLDPOS: MOV DL, x MOV DH, y CALL SET_CURSOR MOV DL, ' ' CALL SHOW_CHARACTER RET 判断新的位置是否合法： 获得新的位置里面的字符 该字符为空格，表示可以移动 不为空，进入POS_NOTEMPTY函数判断是否为 ‘ A ’，为 ‘ A ‘，获胜；反之，表示撞到了墙，不移动 123456789101112131415161718192021ISVALID_POS: MOV DL, NextX ; get the new position of the player MOV DH, NextY CALL SET_CURSOR MOV BH, 0h CALL GET_CHARACTER ; get the character in the new position MOV position, AL ; if if was empty, then we can the player to that direction CMP position, ' ' JNE POS_NOTEMPTY RET POS_NOTEMPTY: CMP position, 'A' ; if it's the EXIT, then you win!!! JE WIN MOV DL, x MOV DH, y CALL SET_CURSOR MOV NextX, DL MOV NextY, DH ; set the new position the same as the old, it means you hit the wall and can not move CALL PRINT_PLAYER JMP ChangePos ; go back to the ChangePos function, to read the next input 整个游戏过程就是不停的监听键盘输入，获得输入之后进行移动；如果此时已经离开了迷宫，则游戏成功；反之，继续监听键盘输入。 逃离迷宫之后的界面 逃离迷宫后，你将会进入WIN函数，在这个函数里，你将选择是进入下一关（如果还有更高的难度的迷宫）还者是继续游戏（你已经通关所有难度的游戏了，可以重新再玩一次）： 1234567891011121314151617181920WIN: CALL CLEAN_SCREEN LEA DX, MSG_WON CALL SHOW CMP difficulty,02H ; difficulty = 02H, you have pass all the games JNE SHOW_MSG_NEXTLEVEL ; if difficulty != 02H, go to choose if go to the next level JMP EXIT_GAME ; if difficulty == 02H, go to choose if continueEXIT_GAME: LEA DX, MSG_CONTINUE ; print the instruction CALL SHOW CALL READ_INPUT CMP AL, "Y" JNE EXIT JMP GAME_START EXIT: CALL CLEAN_SCREEN MOV AX, 4C00H INT 21H 一些功能函数最后我们需要的提供一些功能函数：清屏，获得某个位置的内容，显示字符串，显示字符，设置光标的位置等 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647; CALL this function to print in the consoleSHOW: MOV AH, 09H INT 21H RET ; CALL this function to print a character in the consoleSHOW_CHARACTER: MOV AH, 02H INT 21H RET ;CALL this function to clean the console CLEAN_SCREEN: MOV AL, 3H MOV AH, 0H INT 10H RET ; Print the player to the console PRINT_PLAYER: MOV DL, player CALL SHOW_CHARACTER RET; Get the input from the keyboard GET_INPUT: MOV AH, 7H INT 21H RET ; Set the position of the cursorSET_CURSOR: MOV AH, 2H INT 10H RET ; Get the character in a positionGET_CHARACTER: MOV AL, 0h MOV AH, 08h INT 10H RET; Get the input READ_INPUT: MOV AH, 01 INT 21H RET 总结整个程序的运行过程就是这样，一开始比较难处理的是如何获取某个位置的字符内容，之后通过使用上面的SET_CURSOR函数和GET_CHARACTER函数就解决了；目前让我比较在意的一点就是迷宫不能做的太大，如果做的太大的话就会导致打印的时候输出很奇怪，不过目前的程序运行起来是没有问题的๑乛◡乛๑ 项目下载：Maze Game X86]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机组成原理与接口设计</category>
      </categories>
      <tags>
        <tag>写着玩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中山大学中级实训——GridWorld]]></title>
    <url>%2Fgridworld%2F</url>
    <content type="text"><![CDATA[终于，๑乛◡乛๑，实训结束了 整个实训过程笔记请看： 中山大学软件工程大二中级实训——GridWorld]]></content>
      <categories>
        <category>学习笔记</category>
        <category>实训</category>
      </categories>
      <tags>
        <tag>写着玩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——（C#）Newtonsoft.Json：一种方便的解析Json字符串的方法]]></title>
    <url>%2Fuwp%2FJsonParsing%2F</url>
    <content type="text"><![CDATA[功能简介之前的一篇博客现代操作系统应用开发：网络编程（一）：Json字符串和Xml字符串解析写过如何解析Json字符串，但是！！！今天发现使用Newtonsoft.Json相对于微软的Windows.Data.Json，可以更加简单的解析Json字符串。 实现过程第一步，建立我们的Json对象这里使用我们上次聚合数据的Json数据，可以直接复制下面的内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&#123; "resultcode": "200", "reason": "查询成功!", "result": &#123; "sk": &#123; /*当前实况天气*/ "temp": "21", /*当前温度*/ "wind_direction": "西风", /*当前风向*/ "wind_strength": "2级", /*当前风力*/ "humidity": "4%", /*当前湿度*/ "time": "14:25" /*更新时间*/ &#125;, "today": &#123; "city": "天津", "date_y": "2014年03月21日", "week": "星期五", "temperature": "8℃~20℃", /*今日温度*/ "weather": "晴转霾", /*今日天气*/ "weather_id": &#123; /*天气唯一标识*/ "fa": "00", /*天气标识00：晴*/ "fb": "53" /*天气标识53：霾 如果fa不等于fb，说明是组合天气*/ &#125;, "wind": "西南风微风", "dressing_index": "较冷", /*穿衣指数*/ "dressing_advice": "建议着大衣、呢外套加毛衣、卫衣等服装。", /*穿衣建议*/ "uv_index": "中等", /*紫外线强度*/ "comfort_index": "",/*舒适度指数*/ "wash_index": "较适宜", /*洗车指数*/ "travel_index": "适宜", /*旅游指数*/ "exercise_index": "较适宜", /*晨练指数*/ "drying_index": ""/*干燥指数*/ &#125;, "future": [ /*未来几天天气*/ &#123; "temperature": "28℃~36℃", "weather": "晴转多云", "weather_id": &#123; "fa": "00", "fb": "01" &#125;, "wind": "南风3-4级", "week": "星期一", "date": "20140804" &#125;, &#123; "temperature": "28℃~36℃", "weather": "晴转多云", "weather_id": &#123; "fa": "00", "fb": "01" &#125;, "wind": "东南风3-4级", "week": "星期二", "date": "20140805" &#125;, &#123; "temperature": "27℃~35℃", "weather": "晴转多云", "weather_id": &#123; "fa": "00", "fb": "01" &#125;, "wind": "东南风3-4级", "week": "星期三", "date": "20140806" &#125;, &#123; "temperature": "27℃~34℃", "weather": "多云", "weather_id": &#123; "fa": "01", "fb": "01" &#125;, "wind": "东南风3-4级", "week": "星期四", "date": "20140807" &#125;, &#123; "temperature": "27℃~33℃", "weather": "多云", "weather_id": &#123; "fa": "01", "fb": "01" &#125;, "wind": "东北风4-5级", "week": "星期五", "date": "20140808" &#125;, &#123; "temperature": "26℃~33℃", "weather": "多云", "weather_id": &#123; "fa": "01", "fb": "01" &#125;, "wind": "北风4-5级", "week": "星期六", "date": "20140809" &#125;, &#123; "temperature": "26℃~33℃", "weather": "多云", "weather_id": &#123; "fa": "01", "fb": "01" &#125;, "wind": "北风4-5级", "week": "星期日", "date": "20140810" &#125; ] &#125;, "error_code": 0&#125; 然后，在项目新建一个Weather.cs的类，然后进入这个文件，在菜单栏里选择编辑——&gt;选择性粘贴——&gt;将Json粘贴为类，如下图： 之后，Visual Studio在Weather.cs文件中将自动生成下面代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// Weather.csnamespace ConsoleForNewtonsoft&#123; class Weather &#123; public class Rootobject &#123; public string resultcode &#123; get; set; &#125; public string reason &#123; get; set; &#125; public Result result &#123; get; set; &#125; public int error_code &#123; get; set; &#125; &#125; public class Result &#123; public Sk sk &#123; get; set; &#125; public Today today &#123; get; set; &#125; public Future[] future &#123; get; set; &#125; &#125; public class Sk &#123; public string temp &#123; get; set; &#125; public string wind_direction &#123; get; set; &#125; public string wind_strength &#123; get; set; &#125; public string humidity &#123; get; set; &#125; public string time &#123; get; set; &#125; &#125; public class Today &#123; public string city &#123; get; set; &#125; public string date_y &#123; get; set; &#125; public string week &#123; get; set; &#125; public string temperature &#123; get; set; &#125; public string weather &#123; get; set; &#125; public Weather_Id weather_id &#123; get; set; &#125; public string wind &#123; get; set; &#125; public string dressing_index &#123; get; set; &#125; public string dressing_advice &#123; get; set; &#125; public string uv_index &#123; get; set; &#125; public string comfort_index &#123; get; set; &#125; public string wash_index &#123; get; set; &#125; public string travel_index &#123; get; set; &#125; public string exercise_index &#123; get; set; &#125; public string drying_index &#123; get; set; &#125; &#125; public class Weather_Id &#123; public string fa &#123; get; set; &#125; public string fb &#123; get; set; &#125; &#125; public class Future &#123; public string temperature &#123; get; set; &#125; public string weather &#123; get; set; &#125; public Weather_Id1 weather_id &#123; get; set; &#125; public string wind &#123; get; set; &#125; public string week &#123; get; set; &#125; public string date &#123; get; set; &#125; &#125; public class Weather_Id1 &#123; public string fa &#123; get; set; &#125; public string fb &#123; get; set; &#125; &#125; &#125;&#125; 添加Newtonsoft.Json 解决方案资源管理器 —&gt; 引用右击—&gt;管理NuGet程序包搜索Newtonsoft.Json并安装 将Json字符串转化为Json对象的函数1234567891011void ToJsonObject(string str)&#123; // 下面两句话就可以将Json字符串解析为Json对象，是不是很简单（乛◡乛） JsonSerializer json = JsonSerializer.Create(); Rootobject weather = json.Deserialize&lt;Rootobject&gt;(new JsonTextReader(new StringReader(str))); // 随便选几个值测试一下对象是不是创建成功了，相信我，成功了（乛◡乛） Console.WriteLine("resultcode: " + weather.resultcode); Console.WriteLine("reason：" + weather.reason); Console.WriteLine("result.today.temperature：" + weather.result.today.temperature);&#125; 在控制台打印出来的结果： 将Json对象转化为Json字符串的函数1234567891011121314// 将Json对象解析为Json字符串private static void ToJsonString()&#123; // 打开文件，下面替换为你要保存的文件路径 FileStream file = new FileStream("C:\\Users\\HP\\Desktop\\output.txt", FileMode.OpenOrCreate); TextWriter stream = new StreamWriter(file); // 下面两句话就可以将Json对象解析为Json字符串，是不是也很简单（乛◡乛） var json = JsonSerializer.Create(); json.Serialize(stream, weather); // 关闭文件流很重要，之前没有关闭流文件导致后面的数据莫名其妙地丢失了 stream.Close();&#125; 打开文件，你将看到转化完的Json字符串 FYI项目下载：ConsoleForNewtonsoft 这个项目是运行在控制台上的C# 程序，同样适用于UWP程序。 顺便推荐一个方便的在谷歌浏览器上查看Json字符串（其实还有很多其他强大的功能）的插件：WEB前端助手(FeHelper) 显示效果截图：]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：MediaElement播放进度和Slider滑块的绑定]]></title>
    <url>%2Fuwp%2FMediaElementAndSlider%2F</url>
    <content type="text"><![CDATA[功能简介使用UWP提供的MediaElement控件制作一个音乐播放器，不使用MediaElement内置的传输控件，使用我们自己创建的控件Slider，将Slider滑块的位置和MediaElement的播放进度绑定，顺带一提，博客示例的音乐播放器的封面在音乐播放的时候会旋转。 注意：这里使用了转换器的知识，未使用过转换器的请看——&gt;传送门 实现效果 播放音乐 实现过程创建转换器类12345678910111213141516//ProgressConverter.csnamespace MediaElementAndSlider&#123; class ProgressConverter : IValueConverter &#123; public object Convert(object value, Type targetType, object parameter, string language) &#123; return ((TimeSpan)value).TotalSeconds; &#125; public object ConvertBack(object value, Type targetType, object parameter, string language) &#123; return TimeSpan.FromSeconds((double)value); &#125; &#125;&#125; 需要注意的地方： Convert 函数的value参数的类型为TimeSpan，为保存MediaElement的播放进度的一个结构体，调用TotalSeconds 函数将返回总共播放的秒数 ConvertBack 函数的value参数的类型为double，为Slider的值，使 TimeSpan.FromSeconds((double)value)将返回一个TimeSpan对象 在MainPage.xaml中添加代码 添加需要的资源 1234&lt;!-- MainPage.xaml --&gt;&lt;Page.Resources&gt; &lt;local:ProgressConverter x:Key="progressConverter"/&gt;&lt;/Page.Resources&gt; 添加需要的控件 12345678910111213141516171819202122232425262728293031323334&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;StackPanel&gt; &lt;!-- 封面 --&gt; &lt;Ellipse x:Name="ellipse" Width="200" Height="200" RenderTransformOrigin="0.5,0.5"&gt; &lt;Ellipse.RenderTransform&gt; &lt;CompositeTransform/&gt; &lt;/Ellipse.RenderTransform&gt; &lt;Ellipse.Resources&gt; &lt;!-- Storyboard是一个动画容器，这里将通过Storyboard实现旋转 --&gt; &lt;Storyboard x:Name="EllStoryboard" RepeatBehavior="Forever"&gt; &lt;DoubleAnimation Duration="0:0:20" To="360" Storyboard.TargetProperty="(UIElement.RenderTransform).(CompositeTransform.Rotation)" Storyboard.TargetName="ellipse" d:IsOptimized="True"/&gt; &lt;/Storyboard&gt; &lt;/Ellipse.Resources&gt; &lt;!--这里用一张图片来填充这个椭圆形--&gt; &lt;Ellipse.Fill&gt; &lt;ImageBrush x:Name="picture" ImageSource="Assets/cover.jpg" /&gt; &lt;/Ellipse.Fill&gt; &lt;/Ellipse&gt; &lt;!-- Source替换为你的音乐的地址 --&gt; &lt;MediaElement x:Name="mediaSimple" Source="ms-appx:///Assets/种族假象.mp3" AutoPlay="False"&gt; &lt;/MediaElement&gt; &lt;!-- 进度条，使用progressConverter转换器 --&gt; &lt;Slider x:Name="progress" Minimum="0" Maximum="100" Value="&#123;Binding ElementName=mediaSimple,Path=Position,Converter=&#123;StaticResource progressConverter&#125;, Mode=TwoWay&#125;"&gt;&lt;/Slider&gt; &lt;/StackPanel&gt;&lt;/Grid&gt;&lt;Page.BottomAppBar&gt; &lt;CommandBar x:Name="commandBar"&gt; &lt;AppBarButton Icon="Play" Click="playClick"/&gt; &lt;AppBarButton Icon="Clear" Click="pauseClick"/&gt; &lt;AppBarButton Icon="Stop" Click="stopClick"/&gt; &lt;/CommandBar&gt; &lt;/Page.BottomAppBar&gt;&lt;/Page&gt; 需要注意的地方： Page.Resources 添加资源 Slider的Value属性实现双向绑定 在MainPage.xaml.cs中添加代码12345678910111213141516171819202122/* 下面的函数都是按钮点击事件 */// 开始播放private void playClick(object sender, RoutedEventArgs e)&#123; mediaSimple.Play(); EllStoryboard.Begin(); progress.Maximum = mediaSimple.NaturalDuration.TimeSpan.TotalSeconds;&#125;// 暂停播放private void pauseClick(object sender, RoutedEventArgs e)&#123; mediaSimple.Pause(); EllStoryboard.Pause();&#125;// 停止播放，回到起始位置private void stopClick(object sender, RoutedEventArgs e)&#123; mediaSimple.Stop(); EllStoryboard.Stop();&#125; 需要注意的地方： 在开始播放的时候设置Slider的最大值 FYI项目下载：MediaElementAndSlider 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：网络编程（一）：Json字符串和Xml字符串解析]]></title>
    <url>%2Fuwp%2FJsonAndXml%2F</url>
    <content type="text"><![CDATA[功能简介好久没写博客了，└༼ ಥ ᗜ ಥ ༽┘！！！ 很简单的功能：分别使用System.Xml.XmlDocument 和 Windows.Data.Json 解析并提取服务器端传来的Xml字符串和Json字符串，这里使用聚合数据API 提供的数据，Xml字符串提供12306火车票查询，Json字符串提供天气查询，示例项目将通过返回的字符串提取我们想要的数据并显示出来 实现效果 Json：天气查询 Xml：12306 火车票查询 输入错误，异常判断 实现过程获得数据首先，我们需要从聚合数据中获得数据并且知道返回的数据的格式，在聚合数据上注册，申请数据（部分数据的需要收费，这里使用的天气查询和12306查询首次申请将赠送500次使用次数），将得到下面的结果： 选择一个接口，如天气查询，我们将使用并解析该接口的返回数据得到我们需要的信息，返回的Json字符串如下所示 1234567891011121314151617181920/* 聚合数据返回的Json字符串数据示例 */&#123; "resultcode": "200", "reason": "查询成功!", "result": &#123; /* 该接口返回了相当详细的数据，可以查看官网获得更多信息 * 这里省略了大部分的内容，只显示出了该次实验需要提取的数据 */ "today": &#123; "city": "天津", "date_y": "2014年03月21日", "week": "星期五", "temperature": "8℃~20℃", /*今日温度*/ "weather": "晴转霾", /*今日天气*/ "weather_id": &#123; /*天气唯一标识*/ "fa": "00", /*天气标识00：晴*/ "fb": "53" /*天气标识53：霾 如果fa不等于fb，说明是组合天气*/ &#125;, &#125;&#125; 另一个例子是火车票查询接口，这里我们通过解析Xml字符串获得我们需要的信息 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;root&gt; &lt;resultcode&gt;200&lt;/resultcode&gt; &lt;reason&gt;查询成功&lt;/reason&gt; &lt;result&gt; &lt;train_info&gt; &lt;name&gt;g4&lt;/name&gt; &lt;start&gt;上海虹桥&lt;/start&gt; &lt;end&gt;北京南&lt;/end&gt; &lt;starttime&gt;14:00&lt;/starttime&gt; &lt;endtime&gt;18:28&lt;/endtime&gt; &lt;mileage/&gt; &lt;/train_info&gt; &lt;station_list&gt; &lt;!-- 这里省略了一下这次项目没有使用的值，可以查看官网获得更多信息 --&gt; &lt;/station_list&gt; &lt;/result&gt;&lt;/root&gt; 在MainPage.xaml中添加需要的控件在这里，我们添加两个文本输入框和两个按钮，用于输入我们的信息 123456789&lt;!-- MainPage.xaml --&gt;&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;StackPanel Margin="10"&gt; &lt;TextBox Header="City" Margin="10" x:Name="cityBox"&gt;&lt;/TextBox&gt; &lt;Button Content="查询天气" Click="queryWeather" Margin="10" x:Name="button"&gt;&lt;/Button&gt; &lt;TextBox Header="Train Id" Margin="10" x:Name="trainBox"&gt;&lt;/TextBox&gt; &lt;Button Content="12306火车票查询" Click="queryTrain" Margin="10"&gt;&lt;/Button&gt; &lt;/StackPanel&gt;&lt;/Grid&gt; 在MainPage.xaml.cs中添加代码 添加对应的成员 1234567891011//MainPage.xaml.cs/* * 以查询火车票为例， * 一般的查询链接为：http://apis.juhe.cn/train/s?name=你想要查询的火车的编号&amp;key=你申请的APPKEY * 因此根据下面的string对象，在查询时将使用：trainStr + 你想要查询的火车的编号 + trainKey */private string trainStr = "http://apis.juhe.cn/train/s?dtype=xml&amp;name=";private string weatherStr = "http://v.juhe.cn/weather/index?format=2&amp;cityname=";//App Key，唯一标识，这里需要替换为你注册申请的链接private string trainKey = "&amp;key=9ec62157b998149569d54ae25cbaa8e5";private string weatherKey = "&amp;key=0e3c2dab2c8a77f4bac1138099a812ea"; 对Json字符串进行解析（查询天气）： 123456789101112131415161718192021222324252627282930313233343536373839404142//MainPage.xaml.csprivate async void queryWeather(object sender, RoutedEventArgs e)&#123; // 根据输入得到Url链接 string url = weatherStr + cityBox.Text.Trim() + weatherKey; HttpClient httpClient = new HttpClient(); var headers = httpClient.DefaultRequestHeaders; //使用HttpClient获取数据 HttpResponseMessage response = await httpClient.GetAsync(url); // 避免中文乱码 response.EnsureSuccessStatusCode(); Byte[] getByte = await response.Content.ReadAsByteArrayAsync(); Encoding code = Encoding.GetEncoding("UTF-8"); string jsonString = code.GetString(getByte, 0, getByte.Length); // 解析Json对象 JsonObject weatherObject = JsonObject.Parse(jsonString); // 如果输入正确，返回的Json字符串的resultcode = 200 if (weatherObject.GetNamedString("resultcode").Equals("200")) &#123; //根据上面的Json字符串进行解析，得到Json字符串中嵌套的Json字符串 JsonObject skObject = JsonObject.Parse(weatherObject.GetNamedValue("result").ToString()); JsonObject todayObject = JsonObject.Parse(skObject.GetNamedValue("today").ToString()); // 使用StringBuilder，可变字符串 StringBuilder stringBuilder = new StringBuilder(); stringBuilder.Append("气温 : " + todayObject.GetNamedString("temperature")); stringBuilder.Append("\n"); stringBuilder.Append("天气 : " + todayObject.GetNamedString("weather")); stringBuilder.Append("\n"); stringBuilder.Append("风向 : " + todayObject.GetNamedString("wind")); stringBuilder.Append("\n"); MessageDialog showDialog = new Windows.UI.Popups.MessageDialog(stringBuilder.ToString()); await showDialog.ShowAsync(); &#125; else &#123; //异常判断 MessageDialog errorDialog = new Windows.UI.Popups.MessageDialog("输入错误！！！"); await errorDialog.ShowAsync(); &#125;&#125; 对Xml字符串进行解析（火车票查询）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344private async void queryTrain(object sender, RoutedEventArgs e)&#123; // 根据输入得到Url链接 string url = trainStr + trainBox.Text.Trim() + trainKey; HttpClient httpClient = new HttpClient(); var headers = httpClient.DefaultRequestHeaders; //使用HttpClient获取数据 HttpResponseMessage response = await httpClient.GetAsync(url); // 避免中文乱码 response.EnsureSuccessStatusCode(); Byte[] getByte = await response.Content.ReadAsByteArrayAsync(); Encoding code = Encoding.GetEncoding("UTF-8"); string xmlString = code.GetString(getByte, 0, getByte.Length); // 根据返回的Xml字符串创建Xml对象 XmlDocument doc = new XmlDocument(); doc.LoadXml(xmlString); XmlNode root = doc.DocumentElement; // 如果输入正确，返回的Json字符串的resultcode = 200 if (doc.GetElementsByTagName("resultcode")[0].InnerText.Equals("200")) &#123; //根据上面的Xml字符串进行解析 XmlNodeList child = doc.GetElementsByTagName("train_info")[0].ChildNodes; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.Append("车次 : " + child[0].InnerText); stringBuilder.Append("\n"); stringBuilder.Append("出发站 : " + child[1].InnerText); stringBuilder.Append("\n"); stringBuilder.Append("到达站 : " + child[2].InnerText); stringBuilder.Append("\n"); stringBuilder.Append("出发时间 : " + child[3].InnerText); stringBuilder.Append("\n"); stringBuilder.Append("到达时间 : " + child[4].InnerText); stringBuilder.Append("\n"); MessageDialog showDialog = new Windows.UI.Popups.MessageDialog(stringBuilder.ToString()); await showDialog.ShowAsync(); &#125; else &#123; MessageDialog errorDialog = new Windows.UI.Popups.MessageDialog("输入错误！！！"); await errorDialog.ShowAsync(); &#125; 需要注意的地方： 根据自己注册和申请的接口修改对应的Url 和 AppKey 使用UTF-8避免中文乱码 使用JsonObject解析Json字符串内嵌的Json字符串，提取我们想要的信息 使用XmlDocument 解析Xml字符串 总结关于Json字符串和Xml字符串的解析，可以查看微软官方文档获取更加深入的理解 ：JsonObject Class，XmlDocument Class 关于UWP网络编程，解析Json字符串和Xml字符串只是冰山一角，有空的话，将会补充其他一些关于网络编程的内容（才怪） FYI项目下载：JsonAndXmlSample 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥) 补充另一种更加简单的Json字符串解析方法：Newtonsoft.Json (￣ε(#￣)☆╰╮o(￣皿￣///)不早说]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——SQLite数据库实现数据持久化]]></title>
    <url>%2Fuwp%2FSQLiteSample%2F</url>
    <content type="text"><![CDATA[功能简介利用SQLite数据库实现数据的持久化，以及对数据项的增、删、改、查，使用SQLite Expert查看数据库内容；博客示例项目包括一个MainPage，MainPage左边有一个ListView，用于显示数据库里的所有数据；右边包括一个搜索界面和修改界面，可以用于对数据库里的内容进行搜索和更新/添加新的数据项； 博客示例项目涉及到一些其他的内容，请确保你对下面内容有所了解再使用（可以参考链接的博客）： LocalFolder SQLite数据库的使用 双向数据绑定 实现效果 主界面 数据库保存在LocalFolder中 使用SQLite Expert查看数据库的内容 对数据库内容进行更新 对数据库内容进行搜索 实现过程环境配置 将SQLite包含到应用包内：工具—&gt;拓展和更新—&gt;联机—&gt;搜索SQLitefor Univeral Windows Platform—&gt;安装 右击项目 “引用” &gt;&gt; 选择 “添加引用” &gt;&gt; 在弹出的窗口左侧栏选择 “Universal Windows” “扩展” &gt;&gt;选择“SQLite for Universal Windows Platform后确定 在引用右键管理NuGet程序包搜索SQLitePCL并安装 最终效果 新建类DBServiceDBService类是我们用于数据库管理的类，所有对数据库的操作都要通过DBService来进行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123//DBService.csnamespace SQLiteSample&#123; class DBService &#123; public DBService() &#123; //建立连接，如果MySQLite.db不存在，则会新建MySQLite.db conn = new SQLiteConnection("MySQLite.db"); //获取表，如果Items表不存在，则新建表Items string sql = @"CREATE TABLE IF NOT EXISTS ITEMS( ID INTEGER PRIMARY KEY NOT NULL, TITLE VARCHAR(50), DETAIL VARCHAR(200) );"; using (var statement = conn.Prepare(sql)) &#123; statement.Step(); &#125; &#125; private SQLiteConnection conn; //一些需要的SQL语句 private String SQL_DELETE = "DELETE FROM ITEMS" + " WHERE ID = ?"; private String SQL_UPDATE = "UPDATE ITEMS" + " SET TITLE = ? , DETAIL = ? WHERE ID = ?"; private String SQL_INSERT = "INSERT INTO ITEMS (TITLE,DETAIL)" + " VALUES(?,?);"; private String SQL_SELECT_ALL = "SELECT * FROM ITEMS"; private String SQL_QUERY = "SELECT * FROM ITEMS WHERE TITLE LIKE (?) OR DETAIL LIKE (?);"; private String SQL_GETID = "SELECT ID FROM ITEMS WHERE TITLE = (?) OR DETAIL = (?);"; //初始化，获得本地数据库中的所有Item internal void Initialize(ObservableCollection&lt;Item&gt; allItems) &#123; //使用SQL_SELECT_ALL语句获得所有的内容 using (var statement = conn.Prepare(SQL_SELECT_ALL)) &#123; //statement.Step()将依次获得每一行的结果 while (SQLiteResult.ROW == statement.Step()) &#123; int id = int.Parse(statement[0].ToString()); string title = (string)statement[1]; string detail = (string)statement[2]; allItems.Add(new Item(id, title, detail)); &#125; &#125; &#125; //增 internal int CreateItem(Item item) &#123; //往数据库中添加数据 using (var statement = conn.Prepare(SQL_INSERT)) &#123; //这里的Bind会依次替换掉上面语句中的问号 statement.Bind(1, item.Title); statement.Bind(2, item.Detail); statement.Step(); &#125; /* * 用于得到之前添加的数据的Id，其实这里的操作不太规范，因为通过title和detail可能相同 * 不过这里只是为了演示如何使用数据库，就不要太在意这个了，（乛◡乛） */ using (var statement = conn.Prepare(SQL_GETID)) &#123; statement.Bind(1, item.Title); statement.Bind(2, item.Detail); if (SQLiteResult.ROW == statement.Step()) &#123; return int.Parse(statement[0].ToString()); &#125; &#125; return 0; &#125; //更新 internal void UpdateItem(Item item) &#123; using (var statement = conn.Prepare(SQL_UPDATE)) &#123; statement.Bind(1, item.Title); statement.Bind(2, item.Detail); statement.Bind(3, item.Id); statement.Step(); &#125; &#125; //查 internal async void queryItem(string text) &#123; //StringBuilder与string的差别是一个可变字符串，在使用上和String差不多 StringBuilder strB = new StringBuilder(); using (var statement = conn.Prepare(SQL_QUERY)) &#123; string key = "%" + text + "%"; statement.Bind(1, key); statement.Bind(2, key); while (SQLiteResult.ROW == statement.Step()) &#123; strB.Append("Title: "); strB.Append(statement[1].ToString()); strB.Append(" Detail: "); strB.Append(statement[2].ToString()); strB.Append("\n"); &#125; &#125; MessageDialog searchDialog = new Windows.UI.Popups.MessageDialog(strB.ToString()); await searchDialog.ShowAsync(); &#125; //删 internal void DeleteItem(int id) &#123; using (var statement = conn.Prepare(SQL_DELETE)) &#123; statement.Bind(1, id); statement.Step(); &#125; &#125; &#125;&#125; 需要注意的地方： 在构造函数中连接数据库 预先声明的SQL语句 statement.Bind()将对SQL里的值进行添值 statement.Step()在在数据库中执行该语句 新建Item类 这个类的内容没什么重要的，Item中有三个属性，一个title，一个detail，一个id，对应数据库中一行中的数据；Item类只是为了示例需要，由于篇幅关系，这部分省略，具体代码可以下载下面的示例项目 在MainPage.xaml中添加控件 由于篇幅关系，这部分省略，具体代码可以下载下面的示例项目 在MainPage.xaml.cs的构造函数上添加代码首先，我们需要添加一个DBServie对象 1private DBService itemDBService = new DBService(); 然后针对需要只用对应的函数 12345678910//列表项初始化itemDBService.Initialize(allItems);//增itemDBService.CreateItem(rightItem);//删：item.Id为Primary KeyitemDBService.DeleteItem(item.Id);//查：Query为MainPage的一个文本框，Query.Text得到查询的输入内容itemDBService.queryItem(Query.Text);//改itemDBService.UpdateItem(rightItem); 由于篇幅关系，这部分省略，具体代码可以下载下面的示例项目 总结整个项目最重要的就是第一步环境配置和第二步DBService类代码的编写，其它的地方就可以通过调用DBService的函数连接数据库啦； FYI项目下载：SQLiteSample 运行前首先需要按上面实现过程的第一步配置环境！！！ 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——LiveTileSample：动态磁贴]]></title>
    <url>%2Fuwp%2FLiveTileSample%2F</url>
    <content type="text"><![CDATA[功能简介动态磁贴是UWP的一项新功能，具体效果如下，不了解UWP动态磁贴的可以看微软的官方介绍（传送门） 博客示例包括一个MainPage，如下图所示，包括一个Image控件和两个文本框（可以用于输入标题和内容），两个按钮，一个可以更改图片，一个可以添加磁贴； 对于你新建的磁贴，首先，你需要把你的程序拖动到右边（如下面的视频所示），或者右键选择固定到开始屏幕；你可以添加多个磁贴实现滚动效果，但是UWP的磁贴最多只会保存你最后添加的5个磁贴； 实现效果 实现过程添加引用Microsoft.Toolkit.Uwp.Notifications 在引用右键管理NuGet程序包搜索Microsoft.Toolkit.Uwp.Notifications并安装 在App.xaml.cs的构造函数中添加代码12345678910//App.xaml.cspublic App()&#123; this.InitializeComponent(); this.Suspending += OnSuspending; // 每次启动的时候要清空队列 TileUpdateManager.CreateTileUpdaterForApplication().Clear(); // 实现通知循环 TileUpdateManager.CreateTileUpdaterForApplication().EnableNotificationQueue(true); &#125; 需要注意的地方： TileUpdateManager.CreateTileUpdaterForApplication().Clear()； TileUpdateManager.CreateTileUpdaterForApplication().EnableNotificationQueue(true); 新建类LiveTileService12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//LiveTileService.cspublic class LiveTileService&#123; //添加动态磁贴，title为磁贴的标题，detail为磁贴的内容，source为背景图片 public void AddTile(string title, string detail, string source) &#123; //得到磁贴的对象 TileContent content = CreateTileContent(title, detail, source); var notification = new TileNotification(content.GetXml()); //添加到磁贴的队列 TileUpdateManager.CreateTileUpdaterForApplication().Update(notification); &#125; //创建磁贴对象并返回 private TileContent CreateTileContent(string title, string detail, string source) &#123; return new TileContent() &#123; Visual = new TileVisual() &#123; //这里限于篇幅只写了TileMedium，其实还有TileLarge和TileMedium,TileWide,对应不同磁贴的大小 TileMedium = new TileBinding() &#123; Content = new TileBindingContentAdaptive() &#123; Children = &#123; new AdaptiveText() &#123; Text = title,//设置标题 HintStyle = AdaptiveTextStyle.Title &#125;, new AdaptiveText() &#123; Text = detail,//设置内容 HintStyle = AdaptiveTextStyle.Subtitle &#125; &#125;, BackgroundImage = new TileBackgroundImage() &#123; Source = source //设置背景图片 &#125; &#125; &#125; &#125; &#125;; &#125;&#125; 需要注意的地方： AddTile 为添加磁贴的函数 CreateTileContent中新建TileContent时注意Content不能少 在MainPage.xaml中添加控件12345678910111213//MainPage.xaml&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;StackPanel&gt; &lt;!-- Image的Source指向的是我的Assets文件夹中的图片，在你的代码中需要对此处进行更改 --&gt; &lt;Image x:Name="MyImage" Source="ms-appx:///Assets/spider.jpg" Width="280" Height="280"&gt;&lt;/Image&gt; &lt;TextBlock Text="标题" HorizontalAlignment="Center" Margin="5"&gt;&lt;/TextBlock&gt; &lt;TextBox x:Name="MyTitle" Width="380" Margin="5"&gt;&lt;/TextBox&gt; &lt;TextBlock Text="内容" HorizontalAlignment="Center" Margin="5"&gt;&lt;/TextBlock&gt; &lt;TextBox x:Name="MyDetail" Width="380" Height="50" TextWrapping="Wrap" Margin="5"&gt;&lt;/TextBox&gt; &lt;Button Content="更改图片" Click="ChangeImage" HorizontalAlignment="Center" Margin="5"&gt;&lt;/Button&gt; &lt;Button Content="添加磁贴" Click="AddTile" HorizontalAlignment="Center" Margin="5"&gt;&lt;/Button&gt; &lt;/StackPanel&gt;&lt;/Grid&gt; 在MainPage.xaml.cs文件中添加代码1234567891011121314151617181920212223242526272829303132333435363738394041424344public sealed partial class MainPage : Page&#123; //新建LiveTileService对象 private LiveTileService liveTileService; //保存图片路径，添加磁贴时将使用该图片路径 private string source; public MainPage() &#123; liveTileService = new LiveTileService(); //设置默认值 source = "ms-appx:///Assets/spider.jpg"; this.InitializeComponent(); &#125; private void AddTile(object sender, RoutedEventArgs e) &#123; //添加磁贴 liveTileService.AddTile(MyTitle.Text, MyDetail.Text, source); &#125; private async void ChangeImage(object sender, RoutedEventArgs e) &#123; //选取图片 FileOpenPicker openPicker = new FileOpenPicker(); openPicker.FileTypeFilter.Add(".jpg"); StorageFile file = await openPicker.PickSingleFileAsync(); if (file != null) &#123; //设置Image为选择的图片 BitmapImage bitmap = new BitmapImage(); using (var stream = await file.OpenAsync(Windows.Storage.FileAccessMode.Read)) &#123; bitmap.SetSource(stream); &#125; MyImage.Source = bitmap; //将图片保存在LocalFolder StorageFolder localFolder = ApplicationData.Current.LocalFolder; StorageFile fileCopy = await file.CopyAsync(localFolder, file.Name, NameCollisionOption.ReplaceExisting); &#125; source = "ms-appdata:///local/" + file.Name; &#125; &#125; 需要注意的地方： source默认值的设置 每次上传图片后需要保存到LocalFolder，添加磁贴时磁贴才能通过Source读取图片，关于文件存储的问题可以参考博客UWP——文件管理（二） FYI项目下载：LiveTileSample 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——UI共享：DataTransferManager]]></title>
    <url>%2Fuwp%2FShowShareUI%2F</url>
    <content type="text"><![CDATA[功能简介使用DataTransferManager的ShowShareUI()功能，实现界面共享 示例项目有一个页面MainPage，页面内只有一个按钮，点击按钮即发生共享界面功能 实现效果 点击按钮 选择其中的邮件 实现过程在MainPage.xaml中添加一个按钮并设置相应事件123&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;Button Content="ShareUI" Click="Button_Click" HorizontalAlignment="Center"&gt;&lt;/Button&gt;&lt;/Grid&gt; 在MainPage.xaml.cs文件中添加代码123456789101112131415161718192021222324252627282930namespace ShowShareUISample&#123; public sealed partial class MainPage : Page &#123; public MainPage() &#123; this.InitializeComponent(); //使ShareRequested函数在共享操作时发生 DataTransferManager.GetForCurrentView().DataRequested += ShareRequested; &#125; private void Button_Click(object sender, RoutedEventArgs e) &#123; //启动共享 DataTransferManager.ShowShareUI(); &#125; //设置想要共享的内容 private void ShareRequested(DataTransferManager sender, DataRequestedEventArgs args) &#123; var deferral = args.Request.GetDeferral(); DataRequest request = args.Request; request.Data.Properties.Title = "ShareUISample"; request.Data.SetText("Description：" + "This is a line from ShareUISample. Welcome to learn UWP."); //flash.jpg是示例代码中Asssets文件夹中的图片，可以将其改为你自己的图片 request.Data.SetBitmap(RandomAccessStreamReference.CreateFromUri(new Uri("ms-appx:///Assets/flash.jpg"))); deferral.Complete(); &#125; &#125;&#125; 需要注意的地方： 在构造函数中绑定方法 在ShareRequested中添加共享的内容（Title和Text是必须的） FYI项目下载：ShowShareUISample 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——文件管理（二）：FileManagement]]></title>
    <url>%2Fuwp%2FFileManagement%2F</url>
    <content type="text"><![CDATA[背景简介我们的UWP程序想要读写本地的文件的时候，往往会遇到权限问题，这里存在着两个解决方法： 第一，电脑上的KnownFolder允许UWP程序直接访问；这里的KnowFolder指的是下面图片中的文件夹： 关于这种方法可以参考第一篇博客，本片博客将主要介绍第二中方法 第二，UWP程序启动时生成的local，temp，roaming（漫游）文件夹，程序对这三个文件夹也具有直接访问权限；当需要访问这些文件夹是，需要在添加ms-appdata:///前缀，如 文件夹 前缀 local ms-appdata:///local/ roaming ms-appdata:///roaming/ temp ms-appdata:///temp/ 当需要获取local文件夹中的AppConfig.xml文件时，可以使用下面的代码： 1var file = await Windows.StorageFile.GetFileFromApplicationUriAsync(new Uri("ms-appdata:///local/AppConfig.xml")); 至于这些文件夹的路径在哪里，我们可以通过下面的代码找到： 12StorageFolder localFolder = ApplicationData.Current.LocalFolder;Debug.WriteLine(localFolder.Path); 这是程序自动生成的一个目录，每个人的路径应该都不一样 功能简介博客示例代码有一个页面MainPage，MainPage里有一个Image控件和一个按钮，点击按钮，将可以从本地选择图片，选好图片后Image将更新，同时该图片将被复制到程序的local文件夹中（如何得到local文件夹的路径看上面） 实现效果 程序启动时 选择一张图片 在本地的local文件夹中 实现过程在MainPage.xaml添加控件123456&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;StackPanel&gt; &lt;Image x:Name="MyImage" Source="/Assets/spider.jpg" Width="380" Height="520"&gt;&lt;/Image&gt; &lt;Button Content="Pick The Image" Click="PickImage" HorizontalAlignment="Center" Margin="10"&gt;&lt;/Button&gt; &lt;/StackPanel&gt;&lt;/Grid&gt; 在MainPage.xaml.cs中添加代码123456789101112131415161718192021222324252627282930313233namespace FileManagementSample&#123; public sealed partial class MainPage : Page &#123; private StorageFile file; public MainPage() &#123; this.InitializeComponent(); &#125; private async void PickImage(object sender, RoutedEventArgs e) &#123; //选取图片 FileOpenPicker openPicker = new FileOpenPicker(); openPicker.FileTypeFilter.Add(".jpg"); StorageFile Pickfile = await openPicker.PickSingleFileAsync(); if (Pickfile != null) &#123; //设置Image为选择的图片 BitmapImage bitmap = new BitmapImage(); using (var stream = await Pickfile.OpenAsync(Windows.Storage.FileAccessMode.Read)) &#123; bitmap.SetSource(stream); &#125; MyImage.Source = bitmap; //将图片保存在LocalFolder StorageFolder localFolder = ApplicationData.Current.LocalFolder; StorageFile fileCopy = await Pickfile.CopyAsync(localFolder, Pickfile.Name, NameCollisionOption.ReplaceExisting); &#125; &#125; &#125;&#125; 需要注意的地方： 通过ApplicationData.Current.LocalFolder获得LocalFolder 总结整个项目其实是相当简单的，在将文件保存在LocalFolder后，我们就可以通过添加上面提到的前缀访问LocalFolder里的文件了，比如说我们代码中保存的图片，可以通过下面的代码访问： 123456789//imagename替换为图片名，如博客的示例代码，imagename将为spider2.jpgvar uri = new System.Uri("ms-appdata:///local/" + imagename);file = await Windows.Storage.StorageFile.GetFileFromApplicationUriAsync(uri);BitmapImage bitmap = new BitmapImage();using (var stream = await file.OpenAsync(Windows.Storage.FileAccessMode.Read))&#123; bitmap.SetSource(stream);&#125;MyImage.Source = bitmap; FYI项目下载：FileManagementSample 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——文件管理（一）：KnownFolder]]></title>
    <url>%2Fuwp%2FKnownFolder%2F</url>
    <content type="text"><![CDATA[功能简介我们的UWP程序想要读写本地的文件的时候，往往会遇到权限问题，这里存在着两个解决方法： 第一，电脑上的KnownFolder允许UWP程序直接访问，这篇博客将接受借助KnownFolder读取和保存图片；这里的KnowFolder指的是下面图片中的文件夹： 第二，UWP程序启动时生成的local，temp，roaming（漫游）文件夹，程序对这三个文件夹也具有直接访问权限（可以参考下一篇博客UWP——文件管理（二））; 博客的示例程序将使用第一种方法，MainPage里有一个Image控件和一个Button控件，当启动程序的时候，Image控件将会进入KnownFolder中的图片文件夹，选中其中的图片（如示例图的detective978.jpg）初始化Image；点击按钮，会将Image的图片保存在KnownFolder的视频文件夹 实现效果 图片文件夹的内容 启动程序后Image控件读取图片文件夹的内容 点击按钮后Image的图片保存到视频文件夹中 实现过程设置Package.appxmanifest文件在解决方案资源管理器中找到Package.appxmanifest文件，点击打开，选择其中的功能，这里可以对UWP应用的各种功能提供权限，我们在图片库和视频库上打勾 在MainPage.xaml添加控件1234567&lt;!-- MainPage.xaml --&gt;&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;StackPanel&gt; &lt;Image x:Name="MyImage" Width="400" Height="600"&gt;&lt;/Image&gt; &lt;Button Content="Save The Image" Click="Button_Click"&gt;&lt;/Button&gt; &lt;/StackPanel&gt;&lt;/Grid&gt; 在MainPage.xaml.cs的构造函数上添加代码12345678910111213141516171819202122232425262728293031323334353637//MainPage.xaml.csnamespace KnownFolderSample&#123; public sealed partial class MainPage : Page &#123; //用于保存图片 StorageFile file; public MainPage() &#123; this.InitializeComponent(); SetImageSource(); &#125; //读取图片库里的图片并赋值给Image private async void SetImageSource() &#123; StorageFolder storageFolder = await KnownFolders.GetFolderForUserAsync(null, KnownFolderId.PicturesLibrary); file = await storageFolder.GetFileAsync("detective978.jpg"); //将图片赋给右侧的Image if (file != null) &#123; BitmapImage bitmap = new BitmapImage(); using (var stream = await file.OpenAsync(Windows.Storage.FileAccessMode.Read)) &#123; bitmap.SetSource(stream); &#125; MyImage.Source = bitmap; &#125; &#125; //点击按钮将图片保存在视频库里 private async void Button_Click(object sender, RoutedEventArgs e) &#123; StorageFolder storageFolder = await KnownFolders.GetFolderForUserAsync(null, KnownFolderId.VideosLibrary); await file.CopyAsync(storageFolder, "KnownFolder.jpg", NameCollisionOption.ReplaceExisting); &#125; &#125;&#125; 总结整个项目其实是相当简单的，需要注意的地方有两个： 在开始的时候在Package.appxmanifest中提供权限 使用KnownFolders.GetFolderForUserAsync获得文件夹 FYI项目下载：KnownFolderSample 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——onSuspend：挂起并关闭]]></title>
    <url>%2Fuwp%2FonSuspend%2F</url>
    <content type="text"><![CDATA[功能简介MainPage里面有一个Image控件和文本框控件，可以更改图片和在文本框中输入内容，Debug模式下选择生命周期事件中的挂起并关闭，重新打开之后还原之前图片的内容和文本框的内容 实现效果 启动 更改内容 挂起并关闭后再启动 实现过程修改App.xaml.cs文件 在类App中添加一个变量，用于判断是否处于挂起状态 12//App.cspublic bool isSuspend = false; 修改OnSuspending函数 123456789private void OnSuspending(object sender, SuspendingEventArgs e)&#123; this.isSuspend = true; var deferral = e.SuspendingOperation.GetDeferral(); //保存应用程序状态并停止任何后台活动 Frame frameState = Window.Current.Content as Frame; ApplicationData.Current.LocalSettings.Values["Navigation"] = frameState.GetNavigationState(); deferral.Complete();&#125; 在OnLaunched函数中添加代码 1234567891011121314151617181920212223protected override void OnLaunched(LaunchActivatedEventArgs e)&#123; Frame rootFrame = Window.Current.Content as Frame; if (rootFrame == null) &#123; rootFrame = new Frame(); rootFrame.NavigationFailed += OnNavigationFailed; if (e.PreviousExecutionState == ApplicationExecutionState.Terminated) &#123;//添加的代码 rootFrame.SetNavigationState((string)ApplicationData.Current.LocalSettings.Values["Navigation"]); &#125; Window.Current.Content = rootFrame; &#125; if (e.PrelaunchActivated == false) &#123; if (rootFrame.Content == null) &#123; rootFrame.Navigate(typeof(MainPage), e.Arguments); &#125; Window.Current.Activate(); &#125;&#125; 在MainPage.xaml中添加控件1234567&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;StackPanel&gt; &lt;Image Source="/Assets/RedHood.jpg"&gt;&lt;/Image&gt; &lt;TextBox Text="This is the default content"&gt;&lt;/TextBox&gt; &lt;Button Content="PickPicture" Click="ChangeImage"&gt;&lt;/Button&gt; &lt;/StackPanel&gt;&lt;/Grid&gt; 在MainPage.xaml.cs中添加代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697namespace onSuspendSample&#123; public sealed partial class MainPage : Page &#123; //source和Content用于保存Image控件的Source和文本框的内容 private string source = ""; private string content = ""; //prefix为LocalFolder的使用前缀 private string prefix = "ms-appdata:///local/"; public MainPage() &#123; this.InitializeComponent(); &#125; //改变图片的按钮点击事件 private async void ChangeImage(object sender, RoutedEventArgs e) &#123; //挑选图片 var openPicker = new Windows.Storage.Pickers.FileOpenPicker(); openPicker.FileTypeFilter.Add(".jpg"); StorageFile file = await openPicker.PickSingleFileAsync(); //保存图片到LocalFolder Windows.Storage.StorageFolder localFolder = Windows.Storage.ApplicationData.Current.LocalFolder; StorageFile fileCopy = await file.CopyAsync(localFolder, file.Name, NameCollisionOption.ReplaceExisting); BitmapImage bitmap = new BitmapImage(); using (var stream = await fileCopy.OpenAsync(Windows.Storage.FileAccessMode.Read)) &#123; bitmap.SetSource(stream); &#125; //source保存图片路径，挂起后重新打开将使用这个值进行还原 source = prefix + file.Name; //设置图片控件的Image属性 MyImage.Source = bitmap; &#125; //进入MainPage时调用 protected override void OnNavigatedTo(NavigationEventArgs e) &#123; //判断是第一次打开还是挂起后打开 if (e.NavigationMode == NavigationMode.New) &#123; ApplicationData.Current.LocalSettings.Values.Remove("MainPage"); &#125; else &#123; if (ApplicationData.Current.LocalSettings.Values.ContainsKey("MainPage")) &#123; //还原值 ApplicationDataCompositeValue composite = ApplicationData.Current.LocalSettings.Values["MainPage"] as ApplicationDataCompositeValue; source = composite["source"].ToString(); content = composite["content"].ToString(); ApplicationData.Current.LocalSettings.Values.Remove("MainPage"); &#125; //更新控件 UpdateWidget(); &#125; &#125; protected override void OnNavigatedFrom(NavigationEventArgs e) &#123; /* * OnNavigatedFrom在离开MainPage是会被调用，有可能是跳转到其他的页面，也有可能是挂起 * suspending判断是否为挂起 */ bool suspending = ((App)App.Current).isSuspend; if (suspending) &#123; //如果是，将source，content的值保存下来，下次再打开的时候还原 ApplicationDataCompositeValue composite = new ApplicationDataCompositeValue(); composite["source"] = source; composite["content"] = MyTextBox.Text; ApplicationData.Current.LocalSettings.Values["MainPage"] = composite; &#125; &#125; //更新控件 private async void UpdateWidget() &#123; //根据路径获取图片 var uri = new System.Uri(source); StorageFile file = await StorageFile.GetFileFromApplicationUriAsync(uri); BitmapImage bitmap = new BitmapImage(); using (var stream = await file.OpenAsync(Windows.Storage.FileAccessMode.Read)) &#123; bitmap.SetSource(stream); &#125; MyImage.Source = bitmap; MyTextBox.Text = content; &#125; &#125;&#125; 需要注意的地方： 代码中LocalFolder的内容涉及UWP的文件操作，可以参考另一篇博客：UWP—文件操作 更改Image的图片后要更新source的值 OnNavigatedFrom函数在离开MainPage时调用，该函数中添加的代码是为了保存控件的属性值 OnNavigatedTo函数在进入MainPage时调用，如果是在挂起后重新进入MainPage，该函数将使用OnNavigatedFrom中保存的值还原Source和content，然后再通过UpdateWidget函数更新控件的属性值 总结整个挂起并还原的功能最重要的就是两个部分： App.cs中添加代码是程序状态可以保存 在MainPage的OnNavigatedFrom函数中保存想要保存的值，在OnNavigatedTo函数中提取之前保存的值 Tips需要注意的是，目前UWP挂起后能保存的数据必须是能序列化的， 即C#的基本类型，因此在页面跳转的时候不能传递自定义的类对象（其实就算不使用挂起功能的话也不推荐在页面跳转中传递自定义的对象，最好只传递基本类型，如果真的要让两个页面共用一个自定义的类对象的话，可以使用单例模式啊V●ᴥ●V） FYI项目下载：onSuspendSample 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——DataBinding（三）：双向数据绑定]]></title>
    <url>%2F%2Fuwp%2FTwoWayDataBinding%2F</url>
    <content type="text"><![CDATA[功能简介示例项目有个一页面MainPage，实现MainPage里的数据双向绑定到界面（ListView）上，在界面的操作对数据模型的修改能实时反映到数据；而数据的变更能实时展现到界面。 实现效果 Array到ListView的数据绑定 ListView到Array的绑定 实现过程新建一个类Item.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//Item.csnamespace TwoWayDataBinding&#123; /* * Item是我们自定义的一个类型，包含三个属性，对应三个控件的属性 * Content --&gt; 文本框的内容 * Source --&gt; Image的Source * Ischecked --&gt; Checkbox的checked * 这里继承了接口INotifyPropertyChanged，当客户端某一属性值发生更改时，发出通知 */ public class Item : INotifyPropertyChanged &#123; private string _content; private string _source; private bool _ischecked; public string Content &#123; get =&gt; _content; set &#123; _content = value; OnPropertyChanged("Content") ; &#125; &#125; public string Source &#123; get =&gt; _source; set &#123; _source = value; OnPropertyChanged("Source"); &#125; &#125; public bool Ischecked &#123; get =&gt; _ischecked; set &#123; _ischecked = value; OnPropertyChanged("Ischecked"); &#125; &#125; public Item(string content, string source, bool ischecked) &#123; this._content = content; this._source = source; this._ischecked = ischecked; &#125; //显示实现接口，实现数据绑定动态更新 public event PropertyChangedEventHandler PropertyChanged; protected void OnPropertyChanged(string propertyName = "") &#123; PropertyChangedEventHandler handler = this.PropertyChanged; if (handler != null) &#123; handler(this, new PropertyChangedEventArgs(propertyName)); &#125; &#125; &#125;&#125; 需要注意的地方： 与上一篇博客相比，对Item类的每一个属性添加了set方法，因为对ListView的修改将导致Item的实时更新，所以需要set方法 继承接口INotifyPropertyChanged set方法中的OnPropertyChanged函数，是为了发送通知，实现数据绑定动态更新 新建一个类CheckBoxConverter作为转换器1234567891011121314151617181920212223242526272829303132333435//CheckBoxConverter.csnamespace TwoWayDataBinding&#123; /* * 转化器，将布尔值转化为Checkbox的IsChecked属性 */ public class CheckBoxConverter : IValueConverter &#123; public object Convert(object value, Type targetType, object parameter, string language) &#123; bool? isChecked = value as bool?; if (isChecked == null || isChecked == false) &#123; return false; &#125; else &#123; return true; &#125; &#125; public object ConvertBack(object value, Type targetType, object parameter, string language) &#123; bool? isChecked = value as bool?; if (isChecked == null || isChecked == false) &#123; return false; &#125; else &#123; return true; &#125; &#125; &#125;&#125; 关于转换器可以看上一篇博客 在MainPage.xaml中添加控件和声明资源文件12345678910111213141516171819202122232425262728293031323334&lt;!-- MainPage.xaml --&gt;&lt;!-- 声明资源文件 --&gt;&lt;Page.Resources&gt; &lt;local:CheckBoxConverter x:Key="ConvertCheck"&gt;&lt;/local:CheckBoxConverter&gt;&lt;/Page.Resources&gt;&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;!-- ItemSource用于指定ListView的数据源 --&gt; &lt;ListView Margin="20,20,50,20" ItemsSource="&#123;x:Bind Array&#125;"&gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate x:DataType="local:Item"&gt; &lt;RelativePanel&gt; &lt;!-- Source="&#123;x:Bind Ischecked&#125;"指定CheckBox是否被选中 --&gt; &lt;CheckBox IsChecked="&#123;x:Bind Ischecked,Converter=&#123;StaticResource ConvertCheck&#125;,Mode=TwoWay&#125;" HorizontalAlignment="Left" VerticalAlignment="Top" Margin="10,10,0,0"&gt;&lt;/CheckBox&gt; &lt;Grid Width="90" x:Name="Space"&gt;&lt;/Grid&gt; &lt;!-- Source="&#123;x:Bind Source&#125;"指定Image图片控件的图片源 --&gt; &lt;Image Source="&#123;x:Bind Source,Mode=OneWay&#125;" HorizontalAlignment="Left" Height="40" Margin="50,10,0,0" VerticalAlignment="Top" Width="40"&gt;&lt;/Image&gt; &lt;!-- Text="&#123;x:Bind Content&#125;"指定文本块的内容，Source和Content都是Item的属性 --&gt; &lt;TextBox Text="&#123;x:Bind Content,Mode=TwoWay&#125;" RelativePanel.RightOf="Space" VerticalAlignment="Top" HorizontalAlignment="Left" FontSize="20" Margin="10,12,0,0"&gt;&lt;/TextBox&gt; &lt;/RelativePanel&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt;&lt;/Grid&gt;&lt;!-- 点击Add按钮将往Array中添加元素 点击ShowResults按钮将打印Array的内容 --&gt;&lt;Page.BottomAppBar&gt; &lt;CommandBar&gt; &lt;AppBarButton Icon="Add" Click="AddButton_Click"/&gt; &lt;AppBarButton Icon="ShowResults" Click="ShowButton_Click"/&gt; &lt;/CommandBar&gt;&lt;/Page.BottomAppBar&gt; 需要注意的地方： 和之前的示例相比，数据绑定的Mode由OneWay变为了TwoWay 在MainPage.cs文件中添加代码12345678910111213141516171819202122232425262728293031323334353637//MainPage.csnamespace TwoWayDataBinding&#123; public sealed partial class MainPage : Page &#123; //用于数据绑定的对象存放在ObservableCollection集合中 public ObservableCollection&lt;Item&gt; Array = new ObservableCollection&lt;Item&gt;(); public MainPage() &#123; Array.Add(new Item("This is the head line, with the pictur 0.png(checked)", "Assets/0.png", true)); Array.Add(new Item("This is the first line, with the pictur 1.png(checked)", "Assets/1.png", true)); Array.Add(new Item("This is the second line, with the pictur 2.png(unchecked)", "Assets/2.png", false)); Array.Add(new Item("This is the third line, with the pictur 3.png(unchecked)", "Assets/3.png", false)); Array.Add(new Item("This is the fourth line, with the pictur 4.png(checked)", "Assets/4.png", true)); this.InitializeComponent(); &#125; //点击添加按钮，将往Array中添加元素，此时我们可以看到ListView实时更新 private void AddButton_Click(object sender, RoutedEventArgs e) &#123; Array.Add(new Item("This is the line you add, with the pictur add.png(unchecked)", "Assets/add.jpg", false)); &#125; /* * 当ListView内的内容发生更改时，点击ShowButton，将触发该事件 * 打印出Array的内容，此时我们可以看到Array的内容随着ListView的变化而变化 */ private void ShowButton_Click(object sender, RoutedEventArgs e) &#123; foreach (var item in Array) &#123; Debug.WriteLine(item.Content + " " + item.Ischecked); &#125; &#125; &#125;&#125; 需要注意的地方： 定义了两个按钮点击相应事件，主要是为了更好地观察到双向绑定的结果 总结整个过程就是这样，其中最重要的地方其实就是Item显示实现接口INotifyPropertyChanged，如果需要转换器的话根据目标类型构造转换器； 其实还有一种方法就是使用MvvmLight的ObservableObject，该类已经实现了这个接口，通过继承这个类既可以实现通知界面更新的功能；具体可见另一篇博客UWP—MvvmLight FYI项目下载：TwoWayDataBinding 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——DataBinding（二）：数据绑定+转换器]]></title>
    <url>%2Fuwp%2FDataBindingWithConverter%2F</url>
    <content type="text"><![CDATA[功能简介在数据绑定的时候，我们有时候会遇到不能直接绑定的情况，如Checkbox的IsChecked属性不能直接绑定一个布尔值，Image的Source属性不能直接绑定到一个string上，这时候就需要添加转换器完成数据绑定 示例项目将编写两个转换器，使Checkbox的IsChecked属性通过转换器绑定一个布尔值上，Image的Source属性通过转换器绑定到一个string上； 示例项目将使用到部分文件存储和双向绑定的内容，但这只是为了演示转换器的功能，本文的重点在于CheckBoxConverter类和ImageConverter的实现，如果想要了解文件存储和双向绑定的内容，可以参考另一篇博客：UWP文件管理和UWP数据绑定——双向绑定 实现效果 启动程序时：Item的属性值通过转换器给Image和Checkbox赋值 点击按钮更改图片，Item的Source属性变化，Image的Source属性值实时更新 实现过程添加一个类CheckBoxConverter该类将继承接口IValueConverter，同时实现接口的两个函数 12345678910111213/** value为需要转化的值* targetType为要转化成的值的类型* parameter为转化时传递的参数，* 根据value的值，返回一个targetType类型的值*/public object Convert(object value, Type targetType, object parameter, string language)&#123; ......&#125;public object ConvertBack(object value, Type targetType, object parameter, string language)&#123; ......&#125; 示例代码中的CheckBoxConverter的功能是将布尔值转化为Checkbox的IsChecked属性值，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//CheckBoxConverter.csnamespace DataBindingWithConverter&#123; /* * 转化器，将布尔值转化为Checkbox的IsChecked属性(System.Nullable`1[System.Boolean]) */ public class CheckBoxConverter : IValueConverter &#123; /* * value为Item的Ischecked 属性，布尔值 * targetType为Checkbox的Ischecked 属性的类型 * parameter为转化时传递的参数，这里为空 */ public object Convert(object value, Type targetType, object parameter, string language) &#123; /* * bool? 表示isChecked可以取null * value as bool? 将value转化为布尔值然后返回，如果不能转化，则返回null */ bool? isChecked = value as bool?; /* * 实际上这里返回的并不是targetType类型的值，而是布尔值 * 但是在代码中返回值为Object，布尔值将被强制转化 * 注意：在类型不能强制转化的情况下，应该根据targetType的类型返回返回需要的值 */ if (isChecked == null || isChecked == false) &#123; return false; &#125; else &#123; return true; &#125; &#125; /* * 因为是单向绑定，所有并不需要编写ConvertBack函数 * 如果使用了双向绑定，可以参考上面函数的写法添加ConvertBack函数的代码 */ public object ConvertBack(object value, Type targetType, object parameter, string language) &#123; throw new NotImplementedException(); &#125; &#125;&#125; 需要注意的地方： 继承接口IValueConverter 根据value和targetType定义Convert函数 同理添加一个类ImageConverter1234567891011121314151617181920//ImageConverter.csnamespace DataBindingWithConverter&#123; class ImageConverter : IValueConverter &#123; //string转ImageSource（Image的Source属性） public object Convert(object value, Type targetType, object parameter, string language) &#123; string source = value as string; ImageSource imageSource = new BitmapImage(new Uri(source)); return imageSource; &#125; //Mode = Oneway，所以不用管ConvertBack的内容 public object ConvertBack(object value, Type targetType, object parameter, string language) &#123; throw new NotImplementedException(); &#125; &#125;&#125; 新建类Item.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//Item.csnamespace DataBindingWithConverter&#123; /* * Item是我们自定义的一个类型，包含三个属性，对应三个控件的属性 * Source --&gt; Image的Source * Ischecked --&gt; Checkbox的checked * 这里继承了接口INotifyPropertyChanged，当Item某一属性值发生更改时，发出通知 * 导致控件的属性也实时更改 * 这里主要是为了测试转化器才这么使用的，可以暂时不用管INotifyPropertyChanged的作用 */ public class Item : INotifyPropertyChanged &#123; private string _source; private bool _ischecked; public string Source &#123; get =&gt; _source; set &#123; _source = value; OnPropertyChanged("Source"); &#125; &#125; public bool Ischecked &#123; get =&gt; _ischecked; set &#123; _ischecked = value; OnPropertyChanged("Ischecked"); &#125; &#125; public Item(string source,bool ischecked) &#123; this._source = source; this._ischecked = ischecked; &#125; //显示实现接口，实现数据绑定动态更新 public event PropertyChangedEventHandler PropertyChanged; protected void OnPropertyChanged(string propertyName = "") &#123; PropertyChangedEventHandler handler = this.PropertyChanged; if (handler != null) &#123; handler(this, new PropertyChangedEventArgs(propertyName)); &#125; &#125; &#125;&#125; 在MainPage.xaml.cs中添加代码123456789101112131415161718192021222324252627282930//MainPage.xaml.csnamespace DataBindingWithConverter&#123; public sealed partial class MainPage : Page &#123; public Item MyItem; //LocalFolder文件存储 private string prefix = "ms-appdata:///local/"; public MainPage() &#123; MyItem = new Item("ms-appx:///Assets/flash.jpg", true); this.InitializeComponent(); &#125; private async void ChangeImage(object sender, RoutedEventArgs e) &#123; var openPicker = new Windows.Storage.Pickers.FileOpenPicker(); openPicker.FileTypeFilter.Add(".jpg"); StorageFile file = await openPicker.PickSingleFileAsync(); //LocalFolder文件存储 Windows.Storage.StorageFolder localFolder = Windows.Storage.ApplicationData.Current.LocalFolder; StorageFile fileCopy = await file.CopyAsync(localFolder, file.Name, NameCollisionOption.ReplaceExisting); //设置MyItem的Source，此时将使用转化器转化为Image的Source值 MyItem.Source = prefix + file.Name; &#125; &#125;&#125; 需要注意的地方： 选择图片后需要把图片保存在LocalFolder，这里主要是因为权限问题 将MyItem的Source值实时更新为新的地址值 在MainPage.xaml中添加代码首先，需要在Grid的上面添加代码： 12345678&lt;!-- 将CheckboxConverter类添加到资源，因为CheckboxConverter和MainPage的命名空间一样，所有使用local x:key可以设置为任何你喜欢的值，下面将通过这个值指向CheckboxConverter--&gt;&lt;Page.Resources&gt; &lt;local:CheckBoxConverter x:Key="ConvertCheck"&gt;&lt;/local:CheckBoxConverter&gt; &lt;local:ImageConverter x:Key="ConvertImage"&gt;&lt;/local:ImageConverter&gt;&lt;/Page.Resources&gt; 然后在Grid中添加控件并绑定，代码如下： 1234567&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;StackPanel&gt; &lt;Image Source="&#123;x:Bind MyItem.Source,Converter=&#123;StaticResource ConvertImage&#125;,Mode=OneWay&#125;" &gt;&lt;/Image&gt; &lt;CheckBox IsChecked="&#123;x:Bind MyItem.Ischecked,Converter=&#123;StaticResource ConvertCheck&#125;,Mode=OneWay&#125;" Content="Whether the CheckBox is checked is depend on the Item."&gt;&lt;/CheckBox&gt; &lt;Button Content="ChangePicture" Click="ChangeImage" Width="300"&gt;&lt;/Button&gt; &lt;/StackPanel&gt;&lt;/Grid&gt; 需要注意的地方： 一开始资源文件的声明 CheckBox的IsChecked属性的绑定，Image的Source属性的绑定 总结总的说来，转化器 + 数据绑定的大致过程就是： 根据需要转化的值和目标类型编写转化器 在xaml.cs中声明资源文件 绑定属性是添加转化器 其实，选择图片后还可以按下面的设置更新Image控件： 123456789101112131415var openPicker = new Windows.Storage.Pickers.FileOpenPicker();openPicker.FileTypeFilter.Add(".jpg");file = await openPicker.PickSingleFileAsync();//将图片赋给右侧的Imageif (file != null)&#123; BitmapImage bitmap = new BitmapImage(); using (var stream = await file.OpenAsync(Windows.Storage.FileAccessMode.Read)) &#123; bitmap.SetSource(stream); &#125; //这里的MyImage为Image的x:Name值 MyImage.Source = bitmap;&#125; 但是为什么不这么做呢？主要是因为两点，一，本文主要是为了演示如何使用转换器，所以更新Item.Source的值然后再使用转换器更新Image；二，在之后使用了MvvmLight之后，你会发现将视图和功能分离的重要性ヽﾐ ´∀｀ﾐノ＜ Tips可能你和我一样不知道Convert和ConvertBack的目标类型是什么，总是搞混，这时候其实我们可以通过Debug.WriteLine()方法打印出目标类型 12using System.Diagnostics;Debug.WriteLine(targetType); FYI项目下载：DataBindingWithConverter 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——DataBinding（一）：简单数据绑定]]></title>
    <url>%2Fuwp%2FSimpleDataBinding%2F</url>
    <content type="text"><![CDATA[功能简介UWP提供了功能强大的数据绑定，假设你有一个集合，数据绑定可以将集合中的数据绑定到xaml的控件上，而且通过模板，你可以只书写一次DataTemplate（数据模板），程序就会自动为你生成多个控件。 示例项目将使用ListView和 ObservableCollection，通过编写DataTemplate，即可实现将集合内的数据自动绑定到ListView中。 实现效果 实现过程添加自定义类Item.cs1234567891011121314151617181920namespace SimpleDataBinding&#123; /* * Item是我们自定义的一个类型，其包含两个属性：content和source（内容和图片地址） */ public class Item &#123; private string _content; private string _source; //封装 public string Content &#123; get =&gt; _content; &#125; public string Source &#123; get =&gt; _source; &#125; public Item(string content, string source) &#123; this._content = content; this._source = source; &#125; &#125;&#125; 在MainPage.xam中添加控件12345678910111213141516171819202122&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;!-- ItemSource用于指定ListView的数据源，这里的Array为MainPage.xml.cs中MainPage类的一个集合 ItemsSource="&#123;x:Bind Array&#125;"将指定ListView的数据源指向MainPage对象的属性Array 该属性为ObservableCollection&lt;Item&gt; --&gt; &lt;ListView Margin="20,20,50,20" ItemsSource="&#123;x:Bind Array&#125;"&gt; &lt;ListView.ItemTemplate&gt; &lt;!-- DataType指定Array中对象的类型，这里的Item为我们自定义的一个类 --&gt; &lt;DataTemplate x:DataType="local:Item"&gt; &lt;RelativePanel&gt; &lt;CheckBox HorizontalAlignment="Left" VerticalAlignment="Top" Margin="10,10,0,0"&gt;&lt;/CheckBox&gt; &lt;Grid Width="90" x:Name="Space"&gt;&lt;/Grid&gt; &lt;!-- Source="&#123;x:Bind Source&#125;"指定Image图片控件的图片源 --&gt; &lt;Image Source="&#123;x:Bind Source&#125;" HorizontalAlignment="Left" Height="40" Margin="50,10,0,0" VerticalAlignment="Top" Width="40"&gt;&lt;/Image&gt; &lt;!-- Text="&#123;x:Bind Content&#125;"指定文本块的内容，Source和Content都是Item的属性 --&gt; &lt;TextBlock Text="&#123;x:Bind Content&#125;" RelativePanel.RightOf="Space" VerticalAlignment="Top" HorizontalAlignment="Left" FontSize="20" Margin="10,12,0,0"&gt;&lt;/TextBlock&gt; &lt;/RelativePanel&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt;&lt;/Grid&gt; 需要注意的地方： 设置ListView的ItemSource 设置DataTemplate的x:DataType 为你想要添加的控件属性设置绑定，如Image控件的Source=”{x:Bind Source}” 在MainPage.xaml.cs中添加代码1234567891011121314151617public sealed partial class MainPage : Page &#123; //ObservableCollection表示一个动态数据集合，它可在添加、删除项目或刷新整个列表时提供通知 //用于数据绑定的对象一般存放在ObservableCollection集合中 public ObservableCollection&lt;Item&gt; Array = new ObservableCollection&lt;Item&gt;(); public MainPage() &#123; //往集合中添加对象 Array.Add(new Item("This is the head line, with the pictur 0.png in Folder /Assets.", "Assets/0.png")); Array.Add(new Item("This is the first line, with the pictur 1.png in Folder /Assets.", "Assets/1.png")); Array.Add(new Item("This is the second line, with the pictur 2.png in Folder /Assets.", "Assets/2.png")); Array.Add(new Item("This is the third line, with the pictur 3.png in Folder /Assets.", "Assets/3.png")); Array.Add(new Item("This is the fourth line, with the pictur 4.png in Folder /Assets.", "Assets/4.png")); this.InitializeComponent(); &#125; &#125; 需要注意的地方： 声明ObservableCollection 在构造函数中往ObservableCollection中添加元素 FYI项目下载：SimpleDataBinding 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——标题栏后退按钮的实现和页面缓存]]></title>
    <url>%2Fuwp%2FBackRequested%2F</url>
    <content type="text"><![CDATA[功能简介示例项目有两个页面，MainPage和NewPage，实现从MainPage跳转到NewPage，再从NewPage后退到MainPage，同时还原Mainpage之前的状态； MainPage.xaml代码如下： 123456789101112&lt;!-- MainPage.xaml --&gt;&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;StackPanel&gt; &lt;!-- 一个文本块，一个文本框（可以在其中输入数据，跳转回来后文本框的内容依然存在） 按钮，点击跳转 --&gt; &lt;TextBlock Text="This is the MainPage" Margin="5" FontSize="40"&gt;&lt;/TextBlock&gt; &lt;TextBox Margin="5"&gt;&lt;/TextBox&gt; &lt;Button Content="Navigate To NewPage" Click="NavigateToNewPage" Margin="5"&gt;&lt;/Button&gt; &lt;/StackPanel&gt;&lt;/Grid&gt; NewPage.xaml的代码如下： 12345&lt;!-- NewPage.xaml --&gt;&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt;、 &lt;!-- 就一行，告诉你页面跳转了 --&gt; &lt;TextBlock Text="This is the NewPage" FontSize="40"&gt;&lt;/TextBlock&gt;&lt;/Grid&gt; 实现效果 跳转前—MainPage：在文本框内随意输入内容 跳转后—NewPage：标题栏多了后退按钮 后退—MainPage：之前文本框内的内容被保留了下来 实现过程新建MainPage和NewPage两个页面，并且将上面的xaml代码复制到这两个页面的代码中关于新建一个页面的方法： 解决方案资源管理器—&gt;添加—&gt;新建项—&gt;Visual C#—&gt;空白页 修改App.xaml.cs 在 OnLaunched方法中添加下面的代码 123456789/** 这里用到了事件的C#事件订阅* SystemNavigationManager.GetForCurrentView().BackRequested将在后退导航的时候发生，* 而 += 符号右边的BackRequested是我们自定义的函数，将在下面声明定义* += 符号是该自定义函数在后退导航的时候，会被调用；* 同理，OnNavigated将在跳转到想要的页面的时候调用*/SystemNavigationManager.GetForCurrentView().BackRequested += BackRequested;rootFrame.Navigated += OnNavigated; 在App.xaml.cs中定义函数：BackRequested 123456789101112//后退按钮点击事件private void BackRequested(object sender, BackRequestedEventArgs e)&#123; Frame rootFrame = Window.Current.Content as Frame; //CanGoBack也是系统内置的一个函数 if (rootFrame != null &amp;&amp; rootFrame.CanGoBack) &#123; SystemNavigationManager.GetForCurrentView().AppViewBackButtonVisibility = AppViewBackButtonVisibility.Collapsed; rootFrame.GoBack(); &#125;&#125; 在App.xaml.cs中定义函数：OnNavigated 1234567//跳转到你想要的页面时发生private void OnNavigated(object sender, NavigationEventArgs e)&#123; //AppViewBackButtonVisibility为标题栏后退按钮是否可见 SystemNavigationManager.GetForCurrentView().AppViewBackButtonVisibility = ((Frame)sender).CanGoBack ? AppViewBackButtonVisibility.Visible : AppViewBackButtonVisibility.Collapsed;&#125; 在MainPage.xaml.cs的构造函数上添加代码1this.NavigationCacheMode = Windows.UI.Xaml.Navigation.NavigationCacheMode.Enabled; 这行代码将开启页面缓存，如果需要频繁切换页面，而且页面信息不必实时更新时，使用页面缓存是非常高效的； FYI项目下载：BackRequestedSample 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——自适应界面Adaptive UI(二)]]></title>
    <url>%2Fuwp%2FAdaptiveUI%2F2%2F</url>
    <content type="text"><![CDATA[功能简介 当你看这篇博客的时候，我就假设你已经看过了第一篇博客或者对UWP的自适应界面已经有了一定的了解了；UWP的自适应界面很强大，但是，UWP的自适应界面存在这样的限制，那就是如果你要设置一个控件自适应变换，你就必须给它声明x:Name； 如果我们使用ListView的数据绑定（PS：如果不了解数据绑定，请跳转），那么对于ListView.ItemTemplate里的控件，我们就不能通过声明x:Name绑定到Target上，如下面代码所示 1234567891011121314151617181920212223&lt;!-- MainPage.xaml --&gt;&lt;!-- ItemSource用于指定ListView的数据源，这里的Array为MainPage.xml.cs中MainPage类的一个集合 --&gt;&lt;ListView Margin="20,20,50,20" ItemsSource="&#123;x:Bind Array&#125;" x:Name="MyList"&gt; &lt;ListView.ItemTemplate&gt; &lt;!-- DataType指定Array中对象的类型，这里的Item为我们自定义的一个类 --&gt; &lt;DataTemplate x:DataType="local:Item"&gt; &lt;!-- 这里的ListView对应的模板为一个Checkbox，一个Grid（用于分隔开CheckBox和TextBlock） 一个Imag，还有一个文本框 --&gt; &lt;RelativePanel&gt; &lt;CheckBox HorizontalAlignment="Left" VerticalAlignment="Top" FontSize="14" CharacterSpacing="0" Margin="10,10,0,0"&gt;&lt;/CheckBox&gt; &lt;!-- 在宽屏状态下，Space的宽度为90，这时候文本框和Checkbox中间存在的空间正好存放图片 在窄屏状态下，Space的宽度为0，此时图片隐藏，Checkbox后紧跟着文本框 --&gt; &lt;Grid Width="90" x:Name="Space"&gt;&lt;/Grid&gt; &lt;Image HorizontalAlignment="Left" Height="40" Margin="50,10,0,0" VerticalAlignment="Top" Width="40" Source="&#123;x:Bind Source&#125;" x:Name="MyImage"&gt;&lt;/Image&gt; &lt;TextBlock Text="&#123;x:Bind Content&#125;" RelativePanel.RightOf="Space" VerticalAlignment="Top" HorizontalAlignment="Left" FontSize="20" Margin="10,12,0,0"&gt;&lt;/TextBlock&gt; &lt;/RelativePanel&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt;&lt;/ListView&gt; 如果我们想要在窗口较大的时候显示图片， 而窗口变小的时候隐藏图片，按照之前的方法，我们会发现，即使是在Setter中声明了MyImage.Visibility的Value为Collapsed，图片也不会隐藏 所以这篇博客就是探讨在这种情况下如何实现图片的自适应变化 实现效果 宽屏状态下： 窄屏状态下： 实现过程在MainPage.xml中创建需要的控件这里添加的代码就是上面xaml代码，将上述代码添加到 MainPage.xaml里 添加一个新的类Item位置：解决方案资源管理器—&gt;添加—&gt;新建项—&gt;Visual C#—&gt;代码—&gt;类 在新建的Item.cs文件中添加下面的代码： 12345678910111213141516171819//Item.cs//AdaptiveUIWithListView为你自己所使用的命名空间，namespace AdaptiveUIWithListView&#123; public class Item &#123; private string _content; private string _source; //封装 public string Content &#123; get =&gt; _content; &#125; public string Source &#123; get =&gt; _source; &#125; //构造函数 public Item(string content, string source) &#123; this._content = content; this._source = source; &#125; &#125;&#125; 需要注意的是，这里的AdaptiveUIWithListView为博客的项目所使用的命名空间，你也可以使用自己定义的命名空间 但是如果你使用了自己定义的命名空间，因为MainPage.xaml.cs和MainPage.xaml里都使用了Item，所以需要添加using指令 假如你的Item使用的命名空间为MyNamespace，那么： 首先需要在MainPage.xaml.cs里添加using MyNamespace; 其次，在xaml前几行的Page属性里添加xmlns:mynamespace=”using:MyNamespace” 和DataTemplate的x:DataType=”local:Item”更改为x:DataType=”mynamespace:Item” （这里的mynamespace可以更改为你自己想要的值） 在构造函数上添加函数监听窗口尺寸变化和添加Array这一属性值123456789101112131415161718192021222324252627//MainPage.xaml.cs//ObservableCollection一般用于数据绑定的Sourcpublic ObservableCollection&lt;Item&gt; Array = new ObservableCollection&lt;Item&gt;();public MainPage()&#123; //往Array中添加元素 Array.Add(new Item("This is the head line, with the pictur 0.png in Folder /Assets.", "Assets/0.png")); Array.Add(new Item("This is the first line, with the pictur 1.png in Folder /Assets.", "Assets/1.png")); Array.Add(new Item("This is the second line, with the pictur 2.png in Folder /Assets.", "Assets/2.png")); Array.Add(new Item("This is the third line, with the pictur 3.png in Folder /Assets.", "Assets/3.png")); Array.Add(new Item("This is the fourth line, with the pictur 4.png in Folder /Assets.", "Assets/4.png")); this.InitializeComponent(); //监听窗口大小变化事件 this.SizeChanged += (s, e) =&gt; &#123; if (e.NewSize.Width &gt; 000 &amp;&amp; e.NewSize.Width &lt; 600) &#123; //ShowImage为自定义的函数，见第四步 ShowImage(false); &#125; else &#123; ShowImage(true); &#125; &#125;;&#125; 定义ShowImage函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//flag决定图片是否显示private void ShowImage(bool flag)&#123; /* * FindChildren是一个自定义的函数，接受两个参数，一个是List&lt;T&gt;，另一个是窗口的一个控件 * FindChildren运行结束后，将找到该控件的所有子控件中类型为T的控件 * 下面的例子即找到MyList控件中所有类型为RelativePanel的控件 */ List&lt;RelativePanel&gt; list = new List&lt;RelativePanel&gt;(); FindChildren&lt;RelativePanel&gt;(list, MyList); foreach (RelativePanel panel in list) &#123; for (int i = 0; i &lt; panel.Children.Count; i++) &#123; //如果为图片，则判断是否显示 if (panel.Children[i] is Image) &#123; if (flag) &#123; ((Image)panel.Children[i]).Visibility = Visibility.Visible; &#125; else &#123; ((Image)panel.Children[i]).Visibility = Visibility.Collapsed; &#125; &#125; //这里的Grid即xaml中的Space if (panel.Children[i] is Grid) &#123; if (flag) &#123; ((Grid)panel.Children[i]).Width = 90; &#125; else &#123; ((Grid)panel.Children[i]).Width = 40; &#125; &#125; &#125; &#125;&#125;//遍历startNode的子节点，找到类型为T的控件并且放在results中internal static void FindChildren&lt;T&gt;(List&lt;T&gt; results, DependencyObject startNode) where T : DependencyObject &#123; int count = VisualTreeHelper.GetChildrenCount(startNode); for (int i = 0; i &lt; count; i++) &#123; DependencyObject current = VisualTreeHelper.GetChild(startNode, i); if ((current.GetType()).Equals(typeof(T)) || (current.GetType().GetTypeInfo().IsSubclassOf(typeof(T)))) &#123; T asType = (T)current; results.Add(asType); &#125; FindChildren&lt;T&gt;(results, current); &#125; &#125; 总结最后总结一下，整个图片隐藏的过程就是： FYI 其实，之前我还尝试过另一种方法，就是添加自定义控件UserControl的方法，然后在UserControl里设置VisualStateManager的Setter，然后再ListView里RelativePanel替换为 123&lt;UserControl&gt; ......&lt;/UserControl&gt; 这样确实能实现图片的自动隐藏，但是却有出现另一个问题：Item的传值问题 如果使用UserControl，那么Item的属性值就必须传递给UserControl，在Debug模式下，我观察到Item的属性值确确实实已经传递给UserControl，但是UserControl的控件却没有显示出来，所以我想可能是UserControl先渲染出控件，然后才接收Item传递过来的值 如果有好的解决方法，欢迎在下面评论或者邮件（侧边栏点开就能找到了）ᕕ( ՞ ᗜ ՞ )ᕗ 项目下载：AdaptiveUIWithListView 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥) op1=>operation: SizeChanged函数监听窗口变化 op2=>operation: 设置flag的值 op3=>operation: showImage接收flag op4=>operation: Findchildren找到所有的RelativePanel op5=>operation: 根据flag设置RelativePanel里的图片是否隐藏 op1->op2->op3->op4->op5{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代操作系统应用开发：UWP——自适应界面Adaptive UI(一)]]></title>
    <url>%2Fuwp%2FAdaptiveUI%2F1%2F</url>
    <content type="text"><![CDATA[功能简介UWP 自适应界面，布局面板依据可用的屏幕空间，指定界面元素的大小和位置，设置相应控件的属性； 示例项目的实现的功能： 当窗口大小大于600时，同时并排显示两张图片 当窗口大小小于600时，只显示一张图片 实现效果 宽屏状态下： 窄屏状态下： 实现过程在MainPage.xml中创建需要的控件123456789&lt;Grid Background="&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;"&gt; &lt;!-- 创建了两个Image控件，放在Grid的第一列和第二列 --&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width="*"&gt;&lt;/ColumnDefinition&gt; &lt;ColumnDefinition Width="*" x:Name="RightColumn"&gt;&lt;/ColumnDefinition&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Image Grid.Column="0" Source="Assets/left.jpg" &gt;&lt;/Image&gt; &lt;Image Grid.Column="1" Source="Assets/right.jpg"&gt;&lt;/Image&gt;&lt;/Grid&gt; 使用VisualStateManager在你要添加自适应的Grid添加下面这段代码，这里主要是设置了不同的VisualState，直译就是可视状态，不同的可视状态可以在Setter中设置自己想要的值 1234567891011121314151617181920&lt;VisualStateManager.VisualStateGroups&gt; &lt;VisualStateGroup x:Name="LayoutVisualStates"&gt; &lt;!-- 这里设置了两个VisualState：WideLayout和NarrowLayout,x:Name是你自己取得名字 --&gt; &lt;VisualState x:Name="WideLayout"&gt; &lt;VisualState.Setters&gt; &lt;!-- 这里实际上可以包括多个setter，Target为对应控件的属性，Value为你想要设置的属性值 当处于WideLayout状态下时，RightColumn（对应是哪个控件见上面）的宽度被设置为* --&gt; &lt;Setter Target="RightColumn.Width" Value="*"&gt;&lt;/Setter&gt; &lt;/VisualState.Setters&gt; &lt;/VisualState&gt; &lt;VisualState x:Name="NarrowLayout"&gt; &lt;!-- 这里也是同样的道理 --&gt; &lt;VisualState.Setters&gt; &lt;Setter Target="RightColumn.Width" Value="0"&gt;&lt;/Setter&gt; &lt;/VisualState.Setters&gt; &lt;/VisualState&gt; &lt;/VisualStateGroup&gt;&lt;/VisualStateManager.VisualStateGroups&gt; 在构造函数上添加函数监听窗口尺寸变化1234567891011121314151617181920public MainPage()&#123; this.InitializeComponent(); /* * C#事件订阅 * Lambda表达式，s和e为传入参数 */ this.SizeChanged += (s, e) =&gt; &#123; //首先，state默认设置为WideLayout（WideLayout是你在xaml里设置的名字） var state = "WideLayout"; if (e.NewSize.Width &gt; 000 &amp;&amp; e.NewSize.Width &lt; 600) &#123; //如果界面小于600，则将state设置为NarrowLayout state = "NarrowLayout"; &#125; //这里将变换State VisualStateManager.GoToState(this, state, true); &#125;;&#125; 补充关于&lt;Grid.ColumnDefinitions&gt;和&lt;Grid.RowDefinitions&gt; Grid.ColumnDefinitions 和 Grid.RowDefinition 会将整个Grid控件划分行和分列，如上边的例子将会把Grid分为两列 那么ColumnDefinitions里的Width属性表示什么呢？Width表示该列的宽度，有三种取值： Auto：该控件有多宽，呈现出来就有多宽，比如说如果该列的内容是一张图片，那么按原图片的宽度显示出来 具体数值，如400：即直接指定控件的宽度（不推荐直接指定控件的宽度，因为UWP应用是跨平台的，如果指定宽度的话，在一台电脑里也许这个宽度看起来挺好的，换成windowPhone就。。。） “*“或一个整数/小数紧跟着一个星号，表示的是整个Grid控件的宽度减去属性为Auto和具体数值的控件的宽度，剩下的宽度按比例分给这些带星号的控件，数值越大分的越多 下面是一个具体的例子： 12345678910111213141516171819&lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height="*" /&gt; &lt;RowDefinition Height="20" /&gt; &lt;RowDefinition Height="*" /&gt;&lt;/Grid.RowDefinitions&gt;&lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width="*" /&gt; &lt;ColumnDefinition Width="30" /&gt; &lt;ColumnDefinition Width="*" /&gt;&lt;/Grid.ColumnDefinitions&gt;&lt;Grid Grid.Row="0" Grid.Column="0" BorderBrush="AliceBlue" BorderThickness="3"&gt;&lt;/Grid&gt;&lt;Grid Grid.Row="0" Grid.Column="1" BorderBrush="AliceBlue" BorderThickness="3"&gt;&lt;/Grid&gt;&lt;Grid Grid.Row="0" Grid.Column="2" BorderBrush="AliceBlue" BorderThickness="3"&gt;&lt;/Grid&gt;&lt;Grid Grid.Row="1" Grid.Column="0" BorderBrush="AliceBlue" BorderThickness="3"&gt;&lt;/Grid&gt;&lt;Grid Grid.Row="1" Grid.Column="1" BorderBrush="AliceBlue" BorderThickness="3"&gt;&lt;/Grid&gt;&lt;Grid Grid.Row="1" Grid.Column="2" BorderBrush="AliceBlue" BorderThickness="3"&gt;&lt;/Grid&gt;&lt;Grid Grid.Row="2" Grid.Column="0" BorderBrush="AliceBlue" BorderThickness="3"&gt;&lt;/Grid&gt;&lt;Grid Grid.Row="2" Grid.Column="1" BorderBrush="AliceBlue" BorderThickness="3"&gt;&lt;/Grid&gt;&lt;Grid Grid.Row="2" Grid.Column="2" BorderBrush="AliceBlue" BorderThickness="3"&gt;&lt;/Grid&gt; 效果截图： 总结整个自适应界面的实现过程大致就是这样了，其实这其中最重要的部分就是第二部分，VisualStateManager中Setter的设置，除了文中提到的Width设置，你还可以根据自己的需要设置不同的值，反正可以在Xaml文件中设置的控件的属性值都利用Setter设置 FYI项目下载：AdaptiveUISample 友链：C# 事件订阅 项目下载之后记住把Debug模式从ARM换成X86或X64（根据你自己的机型选择），之前一开始学习的时候不知道这一点，从网上下载下来的项目都运行不了，纠结的一逼(╥╯^╰╥)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>现代操作系统应用开发</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
</search>
